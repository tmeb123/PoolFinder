<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pool Finder</title>
</head>
<body>
<div id="pf-host"></div>
<script>
const host = document.getElementById('pf-host');
const shadow = host.attachShadow({ mode: 'open' });

const style = document.createElement('style');
style.textContent = `
  *, *::before, *::after { box-sizing:border-box;margin:0;padding:0; }
  :host {
    display:block;
    --blue:#0075C9; --blue-dark:#005a9e; --blue-lt:#e8f4fd;
    --green:#1a7f4b; --green-lt:#e6f4ec;
    --red:#c0392b; --red-lt:#fdf0ee;
    --gold:#b45309; --gold-lt:#fef3c7;
    --gray-50:#f8f9fa; --gray-100:#f1f3f5; --gray-200:#e9ecef;
    --gray-300:#dee2e6; --gray-500:#868e96; --gray-700:#495057; --gray-900:#212529;
    --white:#ffffff; --radius:6px;
    --shadow:0 1px 3px rgba(0,0,0,0.08),0 1px 2px rgba(0,0,0,0.06);
  }
  .app { background:var(--gray-50);color:var(--gray-900);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;font-size:14px;line-height:1.5;max-width:1200px;margin:0 auto;padding:24px 20px 60px; }

  .app-header { display:flex;align-items:center;gap:14px;padding:20px 24px;background:var(--white);border-bottom:3px solid var(--blue);border-radius:var(--radius) var(--radius) 0 0;box-shadow:var(--shadow);margin-bottom:16px; }
  .logo { width:40px;height:40px;background:var(--blue);border-radius:8px;display:flex;align-items:center;justify-content:center;flex-shrink:0; }
  .logo svg { fill:white;width:22px;height:22px; }
  .app-header h1 { font-size:20px;font-weight:700;color:var(--gray-900);letter-spacing:-0.3px; }
  .app-header p  { font-size:12px;color:var(--gray-500);margin-top:2px; }

  .notice { background:var(--gold-lt);border:1px solid #f6d860;border-left:4px solid var(--gold);border-radius:var(--radius);padding:10px 16px;font-size:12px;color:#92400e;margin-bottom:20px;line-height:1.7; }
  .notice strong { font-weight:700; }

  .section { margin-bottom:28px; }
  .section-title { font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.08em;color:var(--gray-500);margin-bottom:12px;display:flex;align-items:center;gap:8px; }
  .section-title::after { content:'';flex:1;height:1px;background:var(--gray-200); }

  .summary-bar { display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-bottom:28px; }
  .stat-card { background:var(--white);border:1px solid var(--gray-200);border-radius:var(--radius);padding:16px 20px;box-shadow:var(--shadow); }
  .stat-card .num { font-size:28px;font-weight:800;color:var(--blue);line-height:1; }
  .stat-card .num.green { color:var(--green); }
  .stat-card .num.gold  { color:var(--gold); }
  .stat-card .lbl { font-size:11px;color:var(--gray-500);margin-top:4px;font-weight:500; }

  .rec-list { display:flex;flex-direction:column;gap:16px; }
  .rec-card { background:var(--white);border:1px solid var(--gray-200);border-left:4px solid var(--blue);border-radius:var(--radius);padding:20px 24px;box-shadow:var(--shadow); }
  .rec-card.high-value { border-left-color:var(--gold); }
  .rec-card.strong { border-left-color:var(--green); }
  .rec-top { display:flex;justify-content:space-between;align-items:flex-start;flex-wrap:wrap;gap:16px; }

  .badge { display:inline-block;padding:2px 8px;border-radius:3px;font-size:11px;font-weight:600;letter-spacing:0.04em; }
  .badge-blue  { background:var(--blue-lt);color:var(--blue-dark); }
  .badge-green { background:var(--green-lt);color:var(--green); }
  .badge-gold  { background:var(--gold-lt);color:var(--gold); }
  .badge-gray  { background:var(--gray-100);color:var(--gray-700); }
  .badge-pass  { background:var(--green-lt);color:var(--green); }

  .rec-title { font-size:16px;font-weight:700;color:var(--gray-900); }
  .rec-meta  { font-size:12px;color:var(--gray-500);margin-top:4px; }
  .rec-savings { text-align:right;flex-shrink:0; }
  .rec-savings .big   { font-size:26px;font-weight:800;color:var(--green);line-height:1; }
  .rec-savings .sub   { font-size:11px;color:var(--gray-500);margin-top:4px; }
  .rec-savings .total { font-size:12px;font-weight:600;color:var(--gold);margin-top:3px; }

  .chip-row { display:flex;flex-wrap:wrap;gap:6px;margin-top:14px; }
  .chip { padding:4px 10px;border-radius:4px;font-size:12px;font-weight:500;border:1px solid;display:inline-block; }
  .chip-keep { background:var(--green-lt);color:var(--green);border-color:#a7d7bc; }
  .chip-elim { background:var(--red-lt);color:var(--red);border-color:#f0b8b2;text-decoration:line-through;opacity:0.85; }

  .why-box { margin-top:14px;background:var(--gray-50);border:1px solid var(--gray-200);border-radius:4px;padding:12px 14px;font-size:12px;color:var(--gray-700);line-height:1.8; }
  .why-box strong { color:var(--gray-900); }

  /* Demand chart */
  .demand-section { margin-top:16px; }
  .demand-header { display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;flex-wrap:wrap;gap:4px; }
  .demand-title { font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.06em;color:var(--gray-500); }
  .demand-subtitle { font-size:11px;color:var(--gray-500); }
  .demand-chart-wrap { position:relative;background:var(--gray-50);border:1px solid var(--gray-200);border-radius:4px;padding:8px 8px 0;height:80px;overflow:hidden; }
  .demand-bars { display:flex;align-items:flex-end;height:100%;gap:1px; }
  .demand-col { flex:1;display:flex;flex-direction:column;justify-content:flex-end;height:100%; }
  .demand-col-inner { border-radius:2px 2px 0 0;min-height:2px;width:100%; }
  .demand-col-inner.safe   { background:#74c0fc; }
  .demand-col-inner.buffer { background:#ffd43b; }
  .demand-col-inner.over   { background:#ff6b6b; }
  .demand-line { position:absolute;left:8px;right:8px;pointer-events:none; }
  .demand-day-labels { display:flex;gap:1px;margin-top:3px; }
  .demand-day-label { flex:1;text-align:center;font-size:8px;color:var(--gray-500); }
  .demand-legend { display:flex;gap:14px;margin-top:8px;flex-wrap:wrap; }
  .demand-legend-item { display:flex;align-items:center;gap:5px;font-size:11px;color:var(--gray-500); }
  .demand-legend-dot { width:10px;height:10px;border-radius:2px;flex-shrink:0; }

  .savings-row { display:flex;flex-wrap:wrap;gap:24px;margin-top:14px;padding-top:14px;border-top:1px solid var(--gray-200); }
  .savings-item .val { font-size:18px;font-weight:700;color:var(--gray-900); }
  .savings-item .lbl { font-size:11px;color:var(--gray-500); }

  .vehicle-grid { display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:12px; }
  .vehicle-card { background:var(--white);border:1px solid var(--gray-200);border-radius:var(--radius);padding:14px 16px;box-shadow:var(--shadow); }
  .vehicle-card-top { display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px; }
  .vehicle-name { font-size:13px;font-weight:700;color:var(--gray-900); }
  .vehicle-meta { font-size:11px;color:var(--gray-500);margin-top:2px; }

  .heatmap { border-collapse:collapse;width:100%; }
  .heatmap th { font-size:9px;font-weight:600;color:var(--gray-500);text-align:center;padding:2px 1px;letter-spacing:0.02em; }
  .heatmap .row-label { font-size:10px;color:var(--gray-500);padding-right:6px;white-space:nowrap;font-weight:500; }
  .heatmap td.cell { height:20px;border:1px solid var(--gray-100);border-radius:2px;cursor:default;position:relative; }
  .heatmap td.cell:hover::after { content:attr(data-tip);position:absolute;bottom:110%;left:50%;transform:translateX(-50%);background:var(--gray-900);color:white;padding:3px 7px;border-radius:3px;font-size:10px;white-space:nowrap;z-index:100;pointer-events:none; }

  .data-table { width:100%;border-collapse:collapse;background:var(--white);border-radius:var(--radius);overflow:hidden;box-shadow:var(--shadow); }
  .data-table th { background:var(--gray-50);border-bottom:2px solid var(--gray-200);text-align:left;padding:10px 14px;font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.06em;color:var(--gray-500); }
  .data-table td { padding:9px 14px;border-bottom:1px solid var(--gray-100);font-size:13px;vertical-align:middle; }
  .data-table tr:last-child td { border-bottom:none; }
  .data-table tr:hover td { background:var(--gray-50); }
  .data-table tr.pool-row td:first-child { border-left:3px solid var(--green); }
  .bar-wrap { display:flex;align-items:center;gap:8px; }
  .bar { height:6px;border-radius:3px;background:var(--gray-200);width:80px;overflow:hidden; }
  .bar-fill { height:100%;border-radius:3px; }

  .collapse-toggle { display:flex;align-items:center;justify-content:space-between;cursor:pointer;user-select:none;padding:10px 16px;background:var(--white);border:1px solid var(--gray-200);border-radius:var(--radius);font-size:13px;font-weight:600;color:var(--gray-700);box-shadow:var(--shadow);transition:background 0.15s; }
  .collapse-toggle:hover { background:var(--gray-50); }
  .collapse-toggle .toggle-icon { font-size:11px;color:var(--gray-500);transition:transform 0.2s; }
  .collapse-toggle.open .toggle-icon { transform:rotate(180deg); }
  .collapse-body { display:none;margin-top:12px; }
  .collapse-body.open { display:block; }

  .loading { text-align:center;padding:60px 20px;color:var(--gray-500); }
  .spinner { width:32px;height:32px;border:3px solid var(--gray-200);border-top-color:var(--blue);border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto 16px;display:block; }
  @keyframes spin { to { transform:rotate(360deg); } }

  .about-card { background:var(--white);border:1px solid var(--gray-200);border-radius:var(--radius);padding:28px 32px;box-shadow:var(--shadow);line-height:1.8; }
  .about-card h2 { font-size:18px;font-weight:700;color:var(--gray-900);margin-bottom:6px; }
  .about-card h3 { font-size:12px;font-weight:700;color:var(--blue);text-transform:uppercase;letter-spacing:0.07em;margin:22px 0 8px; }
  .about-card p  { font-size:13px;color:var(--gray-700);margin-bottom:10px; }
  .about-card .tagline { font-size:13px;color:var(--gray-500);margin-bottom:20px;padding-bottom:20px;border-bottom:1px solid var(--gray-200); }
  .about-steps { display:flex;flex-direction:column;gap:10px;margin-bottom:10px; }
  .about-step { display:flex;gap:14px;align-items:flex-start; }
  .step-num { width:26px;height:26px;border-radius:50%;background:var(--blue);color:white;font-size:12px;font-weight:700;display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-top:1px; }
  .step-text { font-size:13px;color:var(--gray-700); }
  .step-text strong { color:var(--gray-900); }
  .future-grid { display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px;margin-bottom:10px; }
  .future-card { background:var(--gray-50);border:1px solid var(--gray-200);border-radius:var(--radius);padding:14px 16px; }
  .future-card h4 { font-size:12px;font-weight:700;color:var(--blue);margin-bottom:5px; }
  .future-card p  { font-size:12px;color:var(--gray-700);margin:0;line-height:1.6; }
  .about-footer { margin-top:24px;padding-top:18px;border-top:1px solid var(--gray-200);font-size:12px;color:var(--gray-500);font-style:italic; }

  @media (max-width:600px) {
    .app { padding:12px 12px 40px; }
    .rec-top { flex-direction:column; }
    .rec-savings { text-align:left; }
    .summary-bar { grid-template-columns:repeat(2,1fr); }
  }
`;
shadow.appendChild(style);

const app = document.createElement('div');
app.className = 'app';
app.innerHTML = `
  <div class="app-header">
    <div class="logo">
      <svg viewBox="0 0 24 24"><path d="M18 4H6C4.9 4 4 4.9 4 6v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11h-2v-4H9l3-5 3 5h-2v4z"/></svg>
    </div>
    <div>
      <h1>Pool Finder</h1>
      <p>Fleet vehicle pool optimizer Â· Analyzes 90 days of hourly utilization to find vehicles that never need to be on the road at the same time Â· $8â€“12k/yr operating savings + type-specific capital savings per vehicle eliminated</p>
    </div>
  </div>

  <div class="notice">
    <strong>ğŸ“‹ Demo Note:</strong> Geotab's simulator generates randomized trips uniformly â€” not representative of real-world shift patterns. Pool Finder overlays realistic utility fleet schedules by vehicle type: shift-based patterns for Vans and Pickups, and project-cycle sporadic patterns for Backhoes (active ~1 week per month). Utilization is analyzed across a full <strong>90-day calendar window at hourly resolution (2,160 slots)</strong> so that project-cycle equipment and alternating-week schedules are captured accurately. Vehicle names and depot assignments are pulled live from the Geotab API.
  </div>

  <div class="section">
    <div class="section-title">Fleet Summary</div>
    <div class="summary-bar">
      <div class="stat-card"><div class="num" id="s-vehicles">â€”</div><div class="lbl">Vehicles Analyzed</div></div>
      <div class="stat-card"><div class="num" id="s-trips">â€”</div><div class="lbl">Total Trips Modeled</div></div>
      <div class="stat-card"><div class="num" id="s-pairs">â€”</div><div class="lbl">Complementary Pairs</div></div>
      <div class="stat-card"><div class="num" id="s-groups">â€”</div><div class="lbl">Pool Opportunities</div></div>
      <div class="stat-card"><div class="num green" id="s-elim">â€”</div><div class="lbl">Vehicles Eliminable</div></div>
      <div class="stat-card"><div class="num gold" id="s-annual">â€”</div><div class="lbl">Annual Op Savings</div></div>
      <div class="stat-card"><div class="num gold" id="s-capital">â€”</div><div class="lbl">Capital Savings (one-time)</div></div>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Pool Recommendations â€” Ranked by 3-Year Value</div>
    <div class="rec-list" id="rec-list">
      <div class="loading"><div class="spinner"></div>Connecting to Geotab API and analyzing 90-day fleet utilizationâ€¦</div>
    </div>
  </div>

  <div class="section">
    <div class="collapse-toggle" id="toggle-heatmaps">
      <span>ğŸ—“ Utilization Heatmaps â€” All Vehicles</span>
      <span class="toggle-icon">â–¼</span>
    </div>
    <div class="collapse-body" id="body-heatmaps">
      <div class="vehicle-grid" id="heatmap-grid"></div>
    </div>
  </div>

  <div class="section">
    <div class="collapse-toggle" id="toggle-pairs">
      <span>ğŸ”— Complementary Pair Matrix</span>
      <span class="toggle-icon">â–¼</span>
    </div>
    <div class="collapse-body" id="body-pairs">
      <div style="overflow-x:auto">
        <table class="data-table">
          <thead><tr><th>Vehicle A</th><th>Vehicle B</th><th>Type</th><th>Location</th><th>Overlap</th></tr></thead>
          <tbody id="pairs-body"></tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-title">About Pool Finder</div>
    <div class="about-card">
      <h2>Pool Finder</h2>
      <p class="tagline">A fleet vehicle pool optimizer built for the Geotab Hackathon â€” identifying underutilized vehicles through 90-day calendar utilization analysis and graph-based clique detection.</p>

      <h3>The Real-World Problem</h3>
      <p>Mixed-use fleets â€” like those operated by utilities, municipalities, and construction firms â€” often carry far more vehicles than they actually need at any given moment. The reason isn't that the vehicles are unused; it's that <strong>usage is sequential, not simultaneous</strong>. A van used for a 6am maintenance run sits idle all afternoon while an identical van sits idle all morning waiting for an evening shift. A backhoe deployed on a project for one week sits in the yard for the following three. Neither fleet manager sees this â€” they only see that both are "actively assigned."</p>
      <p>Pool Finder makes this invisible pattern visible. If a group of vehicles never all need to be on the road at the same time, the fleet can safely operate with fewer of them.At $8,000â€“$12,000 per vehicle per year in operating costs, plus $15,000â€“$30,000 in capital value depending on vehicle type â€” Vans at $15k, Pickups at $20k, and Backhoes at $30k â€” eliminating even a handful of vehicles delivers six-figure savings over three years.</p>

      <h3>How the Algorithm Works</h3>
      <div class="about-steps">
        <div class="about-step"><div class="step-num">1</div><div class="step-text"><strong>90-Day Calendar Vectors (2,160 slots).</strong> Each vehicle's trip history is mapped onto a 90-day Ã— 24-hour binary grid â€” 2,160 slots total. Each slot is 1 if the vehicle was in use during that specific hour on that specific calendar day, and 0 otherwise. This preserves real calendar position, meaning a backhoe active in week 1 and one active in week 3 will have zero overlapping 1s â€” something a normalized weekly vector cannot detect.</div></div>
        <div class="about-step"><div class="step-num">2</div><div class="step-text"><strong>Cosine Overlap Scoring.</strong> Every eligible pair of vehicles (same type, same depot) is scored using cosine similarity on their 2,160-slot vectors. A score near 0 means their schedules never overlap in calendar time â€” they are complementary. A score near 1 means they work the same hours on the same days and cannot share a vehicle.</div></div>
        <div class="about-step"><div class="step-num">3</div><div class="step-text"><strong>Sum-Peak Gating.</strong> A pair passes only if summing their two vectors never produces a value above 1.0 in any single hour â€” meaning they are never both needed at the same time. This is the hard physical constraint of pooling.</div></div>
        <div class="about-step"><div class="step-num">4</div><div class="step-text"><strong>Clique Detection (Bronâ€“Kerbosch).</strong> Passing pairs are assembled into a graph and the Bronâ€“Kerbosch algorithm finds all maximal cliques â€” groups where every member is complementary to every other. These become pool candidates.</div></div>
        <div class="about-step"><div class="step-num">5</div><div class="step-text"><strong>Clique Merging & Deduplication.</strong> Cliques sharing members are merged into consolidated groups. Each vehicle is then assigned to exactly one group â€” its highest-value pool â€” so no vehicle ever appears in conflicting recommendations.</div></div>
        <div class="about-step"><div class="step-num">6</div><div class="step-text"><strong>Buffer-Safe Elimination Scoring.</strong> For each group, the peak simultaneous demand across the full 90-day window determines the minimum fleet needed. Pool Finder adds a +1 safety buffer â€” so a group with a peak demand of 3 recommends keeping 4, not 3. Groups of fewer than 3 vehicles are excluded entirely. Everything above the buffered threshold is safely eliminable.</div></div>
      </div>

      <h3>Future Goals â€” Where Pool Finder Goes Next</h3>
      <div class="future-grid">
        <div class="future-card">
          <h4>ğŸ“ GPS-Based Proximity Pooling</h4>
          <p>Today pooling is restricted to the same assigned depot. A future version would use historical GPS coordinates to detect when vehicles from different depots spend most of their operating time in the same geographic zone â€” enabling cross-depot pool recommendations based on where vehicles actually work, not just where they're parked.</p>
        </div>
        <div class="future-card">
          <h4>ğŸ”® Predictive Schedule Modeling</h4>
          <p>Rather than analyzing historical trips alone, future versions could incorporate project calendars, seasonal demand curves, and known schedule changes to forecast future utilization. This would allow recommendations to be forward-looking â€” flagging vehicles that will become poolable after a project ends, or warning when a pool needs to be dissolved due to upcoming demand increases.</p>
        </div>
        <div class="future-card">
          <h4>âš¡ Real-Time Pool Availability Dashboard</h4>
          <p>A live layer on top of Pool Finder could show dispatchers which pooled vehicles are currently in use versus available, updated from the Geotab API in real time. If a shared vehicle is unexpectedly occupied, the system could automatically surface which other pool vehicle is nearest and available for dispatch.</p>
        </div>
        <div class="future-card">
          <h4>ğŸ’° Advanced Depreciation & Maintenance Modeling</h4>
          <p>Rather than using flat per-vehicle cost estimates, a future version would integrate with Geotab's engine hour and odometer data to model true total cost of ownership â€” applying vehicle-specific depreciation curves based on age and mileage, and pulling actual maintenance records to compute real operational savings per vehicle eliminated rather than industry averages.</p>
        </div>
        <div class="future-card">
          <h4>ğŸ— Project-Cycle Aware Grouping</h4>
          <p>Heavy equipment like backhoes and aerial lifts often follows project cycles â€” active for a few weeks, then idle for a month. Future versions would automatically detect these multi-week utilization cycles from GPS history and group equipment by project cadence, enabling smarter sharing across project teams without requiring manual schedule input.</p>
        </div>
        <div class="future-card">
          <h4>ğŸ“Š Fleet Benchmarking & ROI Tracking</h4>
          <p>Once pools are implemented, Pool Finder could automatically track whether predicted savings are materializing â€” comparing actual vehicle utilization against the pooled baseline, reporting realized savings month over month, and flagging vehicles that have drifted out of their pool patterns and may need reassignment or replacement.</p>
        </div>
      </div>

      <h3>Why Geotab?</h3>
      <p>Geotab's MyGeotab platform provides the real-time GPS data, vehicle grouping, and rich API that Pool Finder needs. The add-in pulls live vehicle metadata directly from the API on every load. In production, actual 90-day trip history replaces the synthetic patterns â€” every fleet is different, and the 2,160-slot calendar vector captures whatever utilization patterns actually exist in the data.</p>

      <h3>Built With</h3>
      <p>Pool Finder was built as a vibe coding hackathon project â€” a rapid back-and-forth collaboration with Claude (Anthropic) to design the algorithm, debug the Geotab add-in namespace, solve the Shadow DOM CSS isolation problem, and figure out at 2am why the simulator data was completely uniform. Turns out Geotab's demo database randomizes trips across all 24 hours equally â€” which is exactly why we needed the 90-day calendar vector approach instead of a normalized weekly shape.</p>
      <p>Stack: vanilla JS Â· Shadow DOM for CSS isolation Â· Geotab MyGeotab Add-In SDK Â· Bronâ€“Kerbosch maximal clique detection Â· cosine similarity on 2,160-slot calendar vectors Â· no external dependencies.</p>

      <div class="about-footer">Built for the Geotab Hackathon Â· Pool Finder v2.0 Â· 90-day calendar analysis Â· real vehicle data Â· realistic shift patterns Â· real savings math.</div>
    </div>
  </div>
`;
shadow.appendChild(app);

function $(id) { return shadow.getElementById(id); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CFG = {
  windowDays:          90,
  TOTAL_SLOTS:         90 * 24,   // 2160 â€” one slot per calendar hour
  maxOverlapPair:      0.20,
  mergeShareThreshold: 0.30,
  requireSameType:     true,
  requireSameLocation: true,
  annualOpMid:         10000,
  // Capital savings vary by vehicle type â€” heavier equipment costs more
  capitalByType: {
    Van:     15000,
    Pickup:  20000,
    Backhoe: 30000,
  },
  capitalDefault:      15000,  // fallback for unknown types
  safetyBuffer:        1,         // keep peak+1 always
  minGroupSize:        3,         // no 2-vehicle pools
  minEliminable:       1,         // at least 1 must be removable
};

const DISPLAY_BLOCKS = ['00â€“04','04â€“08','08â€“12','12â€“16','16â€“20','20â€“24'];
const DAYS = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

const GROUP = {
  VAN:    'b279E',
  PICKUP: 'b279F',
  BACKHOE:'b279D',
  NORTH:  'b279A',
  SOUTH:  'b279B',
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRIP GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mkTrip(date, sh, eh) {
  const s = new Date(date); s.setHours(sh,0,0,0);
  // eh=24 means midnight next day
  let e;
  if (eh >= 24) {
    e = new Date(date); e.setDate(e.getDate()+1); e.setHours(0,0,0,0);
  } else {
    e = new Date(date); e.setHours(eh,0,0,0);
  }
  if (e <= s) return null;
  return { start: s.toISOString(), stop: e.toISOString() };
}

function genTrips(fn) {
  const out = [], now = new Date();
  for (let i = CFG.windowDays; i >= 0; i--) {
    const d = new Date(now); d.setDate(d.getDate()-i); d.setHours(0,0,0,0);
    const dow = d.getDay(); // 0=Sun..6=Sat
    const results = fn(d, dow, i);
    results.forEach(t => { if (t) out.push(t); });
  }
  return out;
}

// â”€â”€ Van patterns (7) â€” shift-based â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const VAN_PATTERNS = [
  (d,dow) => dow>=1&&dow<=5 ? [mkTrip(d,7,16)]  : [],   // Day A   Monâ€“Fri 07â€“16
  (d,dow) => dow>=1&&dow<=5 ? [mkTrip(d,7,16)]  : [],   // Day B   (pools with A)
  (d,dow) => dow>=1&&dow<=5 ? [mkTrip(d,8,17)]  : [],   // Day C   08â€“17
  (d,dow) => { if(dow>=1&&dow<=5) return [mkTrip(d,16,23)]; if(dow===6) return [mkTrip(d,8,14)]; return []; }, // Evening
  (d,dow) => [0,1,2,3,4].includes(dow) ? [mkTrip(d,22,24)] : [],  // Night
  (d,dow) => dow>=1&&dow<=6 ? [mkTrip(d,4,8)]   : [],   // Early morning
  (d,dow) => dow===0||dow===6 ? [mkTrip(d,8,16)] : [],  // Weekends
];
const VAN_NOTES = [
  'Monâ€“Fri Day Shift (07â€“16)','Monâ€“Fri Day Shift (07â€“16)','Monâ€“Fri Day Shift (08â€“17)',
  'Monâ€“Fri Evening (16â€“23) + Sat','Sunâ€“Thu Night (22â€“24)',
  'Monâ€“Sat Early Morning (04â€“08)','Weekends Only (08â€“16)',
];

// â”€â”€ Pickup patterns (4) â€” alternating morning/afternoon â”€â”€â”€â”€â”€â”€â”€â”€â”€
// IMPORTANT: order is M,A,M,A so that any 6-pickup depot gets
// exactly 3 morning + 3 afternoon via idx%4 cycling.
// [0,1,2,3,4,5] % 4 = [0,1,2,3,0,1] â†’ M,A,M,A,M,A = 3M+3A âœ“
const PICKUP_PATTERNS = [
  (d,dow) => dow>=1&&dow<=5 ? [mkTrip(d,6,12)]  : [],   // Morning crew A
  (d,dow) => dow>=1&&dow<=5 ? [mkTrip(d,12,18)] : [],   // Afternoon crew A
  (d,dow) => dow>=1&&dow<=5 ? [mkTrip(d,6,12)]  : [],   // Morning crew B
  (d,dow) => dow>=1&&dow<=5 ? [mkTrip(d,12,18)] : [],   // Afternoon crew B
];
const PICKUP_NOTES = [
  'Monâ€“Fri Morning Crew (06â€“12)','Monâ€“Fri Afternoon Crew (12â€“18)',
  'Monâ€“Fri Morning Crew (06â€“12)','Monâ€“Fri Afternoon Crew (12â€“18)',
];

// â”€â”€ Backhoe patterns (6) â€” project-cycle sporadic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3 cycle offsets Ã— 2 hour splits = 6 distinct patterns
// On-cycle: Monâ€“Fri active. Off-cycle weeks: completely idle.
// Different hour splits (AM vs PM) ensure cosine â‰  1 within a cycle.
function makeBackhoePattern(cycleOffset, h1, h2) {
  return (d, dow, daysAgo) => {
    if (dow === 0 || dow === 6) return [];               // no weekends
    const weekNum = Math.floor(daysAgo / 7);
    if ((weekNum + cycleOffset) % 4 !== 0) return [];   // idle 3 of 4 weeks
    return [mkTrip(d, h1, h2)];
  };
}

const BACKHOE_PATTERNS = [
  makeBackhoePattern(0, 6, 14),   // cycle 0, morning shift
  makeBackhoePattern(0, 14, 22),  // cycle 0, afternoon shift
  makeBackhoePattern(1, 6, 14),   // cycle 1, morning shift
  makeBackhoePattern(1, 14, 22),  // cycle 1, afternoon shift
  makeBackhoePattern(2, 6, 14),   // cycle 2, morning shift
  makeBackhoePattern(2, 14, 22),  // cycle 2, afternoon shift
];
const BACKHOE_NOTES = [
  'Project Cycle A â€” Morning (06â€“14, ~1wk/month)',
  'Project Cycle A â€” Afternoon (14â€“22, ~1wk/month)',
  'Project Cycle B â€” Morning (06â€“14, ~1wk/month)',
  'Project Cycle B â€” Afternoon (14â€“22, ~1wk/month)',
  'Project Cycle C â€” Morning (06â€“14, ~1wk/month)',
  'Project Cycle C â€” Afternoon (14â€“22, ~1wk/month)',
];

function assignPattern(type, idx) {
  if (type==='Van')     return VAN_PATTERNS[idx % VAN_PATTERNS.length];
  if (type==='Pickup')  return PICKUP_PATTERNS[idx % PICKUP_PATTERNS.length];
  if (type==='Backhoe') return BACKHOE_PATTERNS[idx % BACKHOE_PATTERNS.length];
  return VAN_PATTERNS[0];
}
function assignNote(type, idx) {
  if (type==='Van')     return VAN_NOTES[idx % VAN_NOTES.length];
  if (type==='Pickup')  return PICKUP_NOTES[idx % PICKUP_NOTES.length];
  if (type==='Backhoe') return BACKHOE_NOTES[idx % BACKHOE_NOTES.length];
  return '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2160-SLOT CALENDAR VECTOR
// Each slot = one specific calendar hour over the 90-day window.
// Value = 1 if vehicle was in use that hour, 0 otherwise.
// Preserves calendar position â€” project-cycle gaps are visible.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildVector(trips) {
  const hits = new Array(CFG.TOTAL_SLOTS).fill(0);
  const now = new Date();
  const todayMidnight = new Date(now); todayMidnight.setHours(0,0,0,0);

  for (const trip of trips) {
    const ts = new Date(trip.start), te = new Date(trip.stop);
    if (te <= ts) continue;
    const cur = new Date(ts); cur.setMinutes(0,0,0);
    while (cur < te) {
      const daysAgo = Math.floor((todayMidnight - new Date(cur.getFullYear(), cur.getMonth(), cur.getDate())) / 86400000);
      if (daysAgo >= 0 && daysAgo < CFG.windowDays) {
        const slot = (CFG.windowDays - 1 - daysAgo) * 24 + cur.getHours();
        if (slot >= 0 && slot < CFG.TOTAL_SLOTS) hits[slot] = 1;
      }
      cur.setHours(cur.getHours()+1);
    }
  }
  return hits;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE ALGORITHM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function cosineOverlap(vA, vB) {
  let dot=0, mA=0, mB=0;
  for (let i=0; i<vA.length; i++) { dot+=vA[i]*vB[i]; mA+=vA[i]*vA[i]; mB+=vB[i]*vB[i]; }
  const d = Math.sqrt(mA)*Math.sqrt(mB);
  return d===0 ? 0 : dot/d;
}
function sumVectors(vecs) { return vecs[0].map((_,i) => vecs.reduce((s,v)=>s+v[i],0)); }
function peakOf(sv)       { return Math.max(...sv); }

function pairEligible(vA, vB) {
  if (CFG.requireSameType     && vA.type     !== vB.type)     return false;
  if (CFG.requireSameLocation && vA.location !== vB.location) return false;
  return true;
}
function calcSavings(n, vehicleType) {
  const cap = (CFG.capitalByType[vehicleType] || CFG.capitalDefault);
  return { n, annualOp:n*CFG.annualOpMid, capital:n*cap, total3yr:n*CFG.annualOpMid*3+n*cap };
}
function fmt(n) { return '$'+Math.round(n).toLocaleString(); }

function findComplementaryPairs(vehicles, vm) {
  const pairs = [];
  for (let i=0; i<vehicles.length; i++) {
    for (let j=i+1; j<vehicles.length; j++) {
      const vA=vehicles[i], vB=vehicles[j];
      if (!pairEligible(vA,vB)) continue;
      const ol = cosineOverlap(vm[vA.id], vm[vB.id]);
      if (ol > CFG.maxOverlapPair) continue;
      const sumPeak = peakOf(sumVectors([vm[vA.id], vm[vB.id]]));
      if (sumPeak <= 1.0) pairs.push({ idA:vA.id, idB:vB.id, overlap:ol });
    }
  }
  return pairs;
}

function findCliques(vehicles, pairs) {
  const vById = Object.fromEntries(vehicles.map(v=>[v.id,v]));
  const adj = {};
  vehicles.forEach(v=>{ adj[v.id]=new Set(); });
  pairs.forEach(p=>{ adj[p.idA].add(p.idB); adj[p.idB].add(p.idA); });
  const candidates = vehicles.filter(v=>adj[v.id].size>0).map(v=>v.id);
  const cliques = [];
  function bk(R,P,X) {
    if (P.length===0&&X.length===0) { if(R.length>=2) cliques.push([...R].sort()); return; }
    const pivot = [...P,...X].reduce((best,v)=>{
      const c=P.filter(u=>adj[v].has(u)).length; return c>best.c?{v,c}:best;
    },{v:null,c:-1}).v;
    const pivotN = pivot ? adj[pivot] : new Set();
    const toProcess = P.filter(v=>!pivotN.has(v));
    for (const v of toProcess) {
      const nb=[...adj[v]];
      bk([...R,v],P.filter(u=>nb.includes(u)),X.filter(u=>nb.includes(u)));
      P=P.filter(u=>u!==v); X=[...X,v];
    }
  }
  bk([],candidates,[]);
  return cliques.map(ids=>({ids,members:ids.map(id=>vById[id])}));
}

function mergeCliques(cliques, vById) {
  let groups = cliques.map(c=>new Set(c.ids));
  let merged = true;
  while (merged) {
    merged = false;
    const next = [];
    for (let i=0; i<groups.length; i++) {
      let absorbed = false;
      for (let j=0; j<next.length; j++) {
        const inter = new Set([...groups[i]].filter(id=>next[j].has(id)));
        const union  = new Set([...groups[i],...next[j]]);
        if (inter.size/union.size >= CFG.mergeShareThreshold) {
          next[j]=union; absorbed=true; merged=true; break;
        }
      }
      if (!absorbed) next.push(new Set(groups[i]));
    }
    groups = next;
  }
  return groups.map(idSet=>{ const ids=[...idSet].sort(); return {ids,members:ids.map(id=>vById[id])}; });
}

function scoreGroups(groups, vm) {
  const scored = [];
  for (const group of groups) {
    if (group.members.length < CFG.minGroupSize) continue;
    const vecs = group.members.map(v=>vm[v.id]);
    const sumVec = sumVectors(vecs);
    const peak = peakOf(sumVec);
    const needed = Math.ceil(peak) + CFG.safetyBuffer;
    const eliminable = group.members.length - needed;
    if (eliminable < CFG.minEliminable) continue;
    let olSum=0, olCount=0;
    for (let i=0; i<vecs.length; i++)
      for (let j=i+1; j<vecs.length; j++) { olSum+=cosineOverlap(vecs[i],vecs[j]); olCount++; }
    const avgOverlap = olCount>0 ? olSum/olCount : 0;
    const vehicleType = group.members[0].type;
    scored.push({ group, sumVec, peak, needed, eliminable, avgOverlap, savings:calcSavings(eliminable, vehicleType) });
  }
  scored.sort((a,b)=>b.savings.total3yr-a.savings.total3yr);
  // Deduplicate â€” each vehicle goes to its highest-value group only
  const claimed = new Set();
  return scored.filter(r => {
    if (r.group.ids.some(id=>claimed.has(id))) return false;
    r.group.ids.forEach(id=>claimed.add(id));
    return true;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HEATMAP â€” aggregates 2160-slot vector back to weekly 4h view for display
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildWeeklyHeatmap(vec2160) {
  // Average each day-of-week Ã— 4h-block across all 90 days
  const sums = new Array(7*6).fill(0), counts = new Array(7*6).fill(0);
  const now = new Date(); const todayMid = new Date(now); todayMid.setHours(0,0,0,0);
  for (let daysAgo=0; daysAgo<CFG.windowDays; daysAgo++) {
    const d = new Date(todayMid); d.setDate(d.getDate()-daysAgo);
    const dow = d.getDay();
    for (let block=0; block<6; block++) {
      let blockVal = 0;
      for (let h=0; h<4; h++) {
        const slot = (CFG.windowDays-1-daysAgo)*24 + block*4 + h;
        if (slot>=0&&slot<CFG.TOTAL_SLOTS) blockVal += vec2160[slot];
      }
      sums[dow*6+block]  += blockVal/4;
      counts[dow*6+block]++;
    }
  }
  return sums.map((s,i) => counts[i]>0 ? s/counts[i] : 0);
}

function renderHeatmap(vec2160) {
  const v = buildWeeklyHeatmap(vec2160);
  const tbl = document.createElement('table'); tbl.className='heatmap';
  const hdr = document.createElement('tr');
  const c = document.createElement('th'); c.style.width='34px'; hdr.appendChild(c);
  DISPLAY_BLOCKS.forEach(b=>{ const th=document.createElement('th'); th.textContent=b; hdr.appendChild(th); });
  tbl.appendChild(hdr);
  DAYS.forEach((day,di)=>{
    const tr=document.createElement('tr');
    const lbl=document.createElement('td'); lbl.className='row-label'; lbl.textContent=day; tr.appendChild(lbl);
    for (let b=0; b<6; b++) {
      const val=v[di*6+b];
      const td=document.createElement('td'); td.className='cell';
      if (val<0.05) td.style.background='#f8f9fa';
      else if (val<0.4) td.style.background=`rgba(0,117,201,${(0.15+val*0.5).toFixed(2)})`;
      else td.style.background=`rgba(0,117,201,${(0.4+val*0.55).toFixed(2)})`;
      td.setAttribute('data-tip',`${day} ${DISPLAY_BLOCKS[b]}: ${(val*100).toFixed(0)}%`);
      tr.appendChild(td);
    }
    tbl.appendChild(tr);
  });
  return tbl;
}

function renderVehicleCard(v, trips, vec) {
  const card=document.createElement('div'); card.className='vehicle-card';
  card.innerHTML=`
    <div class="vehicle-card-top">
      <div>
        <div class="vehicle-name">${v.name}</div>
        <div class="vehicle-meta">${v.type} Â· ${v.location}</div>
        <div class="vehicle-meta">${v.note}</div>
      </div>
      <span class="badge badge-gray">${trips.length} trips</span>
    </div>`;
  const w=document.createElement('div'); w.appendChild(renderHeatmap(vec));
  card.appendChild(w);
  return card;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEMAND CHART â€” shows summed group demand over 90 days, aggregated to daily peaks
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderDemandChart(sumVec, peak, needed, size) {
  // Aggregate 2160-slot sum vector to 90 daily peak values for the chart
  const dailyPeaks = [];
  for (let day=0; day<CFG.windowDays; day++) {
    let dayMax = 0;
    for (let h=0; h<24; h++) {
      const slot = day*24+h;
      if (sumVec[slot] > dayMax) dayMax = sumVec[slot];
    }
    dailyPeaks.push(dayMax);
  }
  const maxVal = Math.max(size, peak, needed+0.5);

  const section = document.createElement('div'); section.className='demand-section';
  const header = document.createElement('div'); header.className='demand-header';
  header.innerHTML=`
    <div class="demand-title">Daily Peak Demand â€” 90-Day Window</div>
    <div class="demand-subtitle">Peak ever: <strong style="color:var(--gray-900)">${peak.toFixed(2)}</strong> simultaneous Â· Keeping: <strong style="color:var(--green)">${needed}</strong> Â· Buffer: +${CFG.safetyBuffer}</div>
  `;
  section.appendChild(header);

  const wrap = document.createElement('div'); wrap.className='demand-chart-wrap';
  const bars = document.createElement('div'); bars.className='demand-bars';

  dailyPeaks.forEach(val => {
    const col = document.createElement('div'); col.className='demand-col';
    const pct = Math.min(100,(val/maxVal)*100);
    const colorClass = val > needed ? 'over' : val > (needed-CFG.safetyBuffer) ? 'buffer' : 'safe';
    const inner = document.createElement('div');
    inner.className=`demand-col-inner ${colorClass}`;
    inner.style.height=`${pct}%`;
    col.appendChild(inner);
    bars.appendChild(col);
  });
  wrap.appendChild(bars);

  // Keep threshold line
  const keepPct = Math.min(100,(needed/maxVal)*100);
  const keepLine = document.createElement('div'); keepLine.className='demand-line';
  keepLine.style.cssText=`bottom:${keepPct}%;border-top:2px dashed var(--green);`;
  keepLine.innerHTML=`<span style="position:absolute;right:4px;font-size:9px;font-weight:800;color:var(--green);transform:translateY(-11px);background:var(--gray-50);padding:0 3px">Keep ${needed}</span>`;
  wrap.appendChild(keepLine);

  // Peak line
  const peakPct = Math.min(100,(peak/maxVal)*100);
  const peakLine = document.createElement('div'); peakLine.className='demand-line';
  peakLine.style.cssText=`bottom:${peakPct}%;border-top:1.5px dashed #74c0fc;`;
  peakLine.innerHTML=`<span style="position:absolute;left:4px;font-size:9px;font-weight:800;color:#4dabf7;transform:translateY(-11px);background:var(--gray-50);padding:0 3px">Peak ${peak.toFixed(1)}</span>`;
  wrap.appendChild(peakLine);

  section.appendChild(wrap);

  // Month labels under chart
  const monthLabels = document.createElement('div'); monthLabels.className='demand-day-labels';
  const monthNames=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const now = new Date();
  let lastMonth = -1;
  for (let day=0; day<CFG.windowDays; day++) {
    const d = new Date(now); d.setDate(d.getDate()-(CFG.windowDays-1-day));
    const lbl=document.createElement('div'); lbl.className='demand-day-label';
    if (d.getMonth()!==lastMonth) { lbl.textContent=monthNames[d.getMonth()]; lastMonth=d.getMonth(); }
    monthLabels.appendChild(lbl);
  }
  section.appendChild(monthLabels);

  const legend = document.createElement('div'); legend.className='demand-legend';
  legend.innerHTML=`
    <div class="demand-legend-item"><div class="demand-legend-dot" style="background:#74c0fc"></div>Within safe threshold</div>
    <div class="demand-legend-item"><div class="demand-legend-dot" style="background:#ffd43b"></div>Safety buffer zone</div>
    <div class="demand-legend-item"><div class="demand-legend-dot" style="background:#ff6b6b"></div>Above keep threshold</div>
  `;
  section.appendChild(legend);
  return section;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REC CARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderRecCard(result) {
  const { group, sumVec, eliminable, needed, peak, avgOverlap, savings } = result;
  const size = group.members.length;
  const tier = eliminable >= 4 ? 'high-value' : eliminable >= 3 ? 'strong' : '';
  const topBadge = eliminable >= 4
    ? `<span class="badge badge-gold">â˜… High Value</span>`
    : eliminable >= 3
    ? `<span class="badge badge-green">Strong Opportunity</span>`
    : `<span class="badge badge-blue">Recommended</span>`;
  const chips = group.members.map((v,i) => {
    const keep = i < needed;
    return `<span class="chip ${keep?'chip-keep':'chip-elim'}">${keep?'âœ“ Keep:':'âœ— Remove:'} ${v.name} <span style="font-size:10px;opacity:0.7">(${v.type})</span></span>`;
  }).join('');

  const capPerVehicle = CFG.capitalByType[group.members[0].type] || CFG.capitalDefault;
  const card = document.createElement('div'); card.className=`rec-card ${tier}`;
  card.innerHTML=`
    <div class="rec-top">
      <div>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;flex-wrap:wrap">
          ${topBadge}
          <span class="badge badge-gray">${group.members[0].type} Â· ${group.members[0].location}</span>
          <span class="badge badge-gray">${size} vehicles â†’ keep ${needed}, remove ${eliminable}</span>
        </div>
        <div class="rec-title">${size} ${group.members[0].type}s â€” pool of ${size}, safely reduced to ${needed}</div>
        <div class="rec-meta">Schedule overlap: ${(avgOverlap*100).toFixed(0)}% avg Â· Peak simultaneous demand: ${peak.toFixed(2)} Â· Safety buffer: +${CFG.safetyBuffer}</div>
      </div>
      <div class="rec-savings">
        <div class="big">${fmt(savings.annualOp)}<span style="font-size:13px;color:#868e96">/yr</span></div>
        <div class="sub">+ ${fmt(savings.capital)} one-time capital savings</div>
        <div class="total">3-yr total value: ${fmt(savings.total3yr)}</div>
      </div>
    </div>
    <div class="chip-row">${chips}</div>
    <div class="why-box">
      <strong>Why this pool works:</strong> Across the full 90-day calendar window (2,160 hourly slots), the combined demand of these ${size} vehicles never exceeds <strong>${peak.toFixed(2)} simultaneously</strong>. Their schedules are genuinely complementary â€” they work different hours, different shifts, or different project weeks and are never all needed at once. Pool Finder rounds up to <strong>${Math.ceil(peak)}</strong> as the strict minimum, then adds a <strong>+${CFG.safetyBuffer} safety buffer</strong> for operational headroom, bringing the recommended fleet size to <strong>${needed} vehicles</strong>. The <strong>${eliminable} vehicle${eliminable>1?'s':''}</strong> above that threshold can be safely eliminated. The chart below shows daily peak demand across all 90 days â€” blue bars confirm demand stays comfortably below the keep threshold.
    </div>
  `;
  card.appendChild(renderDemandChart(sumVec, peak, needed, size));
  const savingsRow = document.createElement('div'); savingsRow.className='savings-row';
  savingsRow.innerHTML=`
    <div class="savings-item"><div class="val">${fmt(savings.annualOp)}</div><div class="lbl">Annual Op Savings<br><span style="color:#2a3060">$8kâ€“$12k/vehicle/yr</span></div></div>
    <div class="savings-item"><div class="val">${fmt(savings.capital)}</div><div class="lbl">Capital Savings<br><span style="color:#2a3060">${fmt(capPerVehicle)}/vehicle one-time</span></div></div>
    <div class="savings-item"><div class="val">${fmt(savings.total3yr)}</div><div class="lbl">3-Year Total Value</div></div>
    <div class="savings-item"><div class="val">${eliminable} of ${size}</div><div class="lbl">Vehicles Removed</div></div>
  `;
  card.appendChild(savingsRow);
  return card;
}

function renderPairRow(vA, vB, ol) {
  const tr=document.createElement('tr'); tr.className='pool-row';
  tr.innerHTML=`
    <td>${vA.name}</td><td>${vB.name}</td>
    <td><span class="badge badge-pass">âœ“ ${vA.type}</span></td>
    <td><span class="badge badge-pass">âœ“ Same</span></td>
    <td><div class="bar-wrap"><div class="bar"><div class="bar-fill" style="width:${(ol*100).toFixed(1)}%;background:#1a7f4b"></div></div><span style="color:#1a7f4b;min-width:34px">${(ol*100).toFixed(0)}%</span></div></td>
  `;
  return tr;
}

function setupCollapsibles() {
  [['toggle-heatmaps','body-heatmaps'],['toggle-pairs','body-pairs']].forEach(([tid,bid])=>{
    const toggle=$(tid), body=$(bid);
    if (!toggle||!body) return;
    toggle.addEventListener('click',()=>{ const open=body.classList.toggle('open'); toggle.classList.toggle('open',open); });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function runPoolFinder(api) {
  api.call('Get', { typeName:'Device', resultsLimit:200 },
    function(devices) {
      // Track idx per type AND per depot so each depot independently cycles
      // through patterns from 0. Without this, South pickups would start at
      // idx=6 and get a skewed morning/afternoon split.
      const typeCounters = {};
      const fleet = [];
      devices.forEach(device => {
        const ids = (device.groups||[]).map(g=>g.id||g);
        const type  = ids.includes(GROUP.VAN)?'Van':ids.includes(GROUP.PICKUP)?'Pickup':ids.includes(GROUP.BACKHOE)?'Backhoe':null;
        const depot = ids.includes(GROUP.NORTH)?'Depot North':ids.includes(GROUP.SOUTH)?'Depot South':null;
        if (!type||!depot) return;
        const key = type + '|' + depot;
        if (!typeCounters[key]) typeCounters[key] = 0;
        const idx = typeCounters[key]++;
        fleet.push({ id:device.id, name:device.name, type, location:depot, note:assignNote(type,idx), pattern:assignPattern(type,idx) });
      });

      if (!fleet.length) {
        $('rec-list').innerHTML='<div style="color:#c0392b;padding:40px;text-align:center">No typed fleet vehicles found.</div>';
        return;
      }

      // Build 2160-slot calendar vectors
      const tripMap={}, vm={};
      const vById = Object.fromEntries(fleet.map(v=>[v.id,v]));
      let totalTrips=0;
      fleet.forEach(v=>{
        const trips=genTrips(v.pattern);
        tripMap[v.id]=trips;
        vm[v.id]=buildVector(trips);
        totalTrips+=trips.length;
      });

      // Heatmaps
      const grid=$('heatmap-grid');
      fleet.forEach(v=>grid.appendChild(renderVehicleCard(v,tripMap[v.id],vm[v.id])));

      // Pairs
      const pairs=findComplementaryPairs(fleet,vm);
      const tbody=$('pairs-body');
      pairs.forEach(p=>{ const vA=vById[p.idA],vB=vById[p.idB]; tbody.appendChild(renderPairRow(vA,vB,p.overlap)); });

      // Cliques â†’ merge â†’ score
      const cliques=findCliques(fleet,pairs);
      const mergedGroups=mergeCliques(cliques,vById);
      const results=scoreGroups(mergedGroups,vm);

      // Render recs
      const recList=$('rec-list'); recList.innerHTML='';
      if (!results.length) {
        recList.innerHTML='<div style="color:#868e96;padding:40px;text-align:center">No actionable pool groups found.</div>';
      } else {
        results.forEach(r=>recList.appendChild(renderRecCard(r)));
      }

      // Summary
      let totalElim=0,totalAnnual=0,totalCapital=0;
      results.forEach(r=>{ totalElim+=r.eliminable; totalAnnual+=r.savings.annualOp; totalCapital+=r.savings.capital; });
      $('s-vehicles').textContent = fleet.length;
      $('s-trips').textContent    = totalTrips.toLocaleString();
      $('s-pairs').textContent    = pairs.length;
      $('s-groups').textContent   = results.length;
      $('s-elim').textContent     = totalElim;
      $('s-annual').textContent   = fmt(totalAnnual);
      $('s-capital').textContent  = fmt(totalCapital);

      setupCollapsibles();
    },
    function(err) {
      $('rec-list').innerHTML='<div style="color:#c0392b;padding:40px;text-align:center">Failed to connect to Geotab API.</div>';
    }
  );
}

geotab = geotab || {};
geotab.addin = geotab.addin || {};
geotab.addin.poolFinder = function() {
  return {
    initialize: function(api, state, callback) { runPoolFinder(api); callback(); },
    focus:      function(api, state) {},
    blur:       function() {},
  };
};
</script>
</body>
</html>
