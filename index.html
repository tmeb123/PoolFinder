<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pool Finder — Logic Validator v5</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Syne:wght@400;600;700;800&display=swap');

    :root {
      --bg: #0d0f12;
      --surface: #151820;
      --surface2: #1a1f2e;
      --border: #232836;
      --text: #e8eaf0;
      --muted: #5a6180;
      --accent: #3de8a0;
      --neutral: #4a90d9;
      --gold: #f5c842;
      --good: #3de8a0;
      --bad: #ff5f6d;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'DM Mono', monospace;
      font-size: 13px;
      line-height: 1.6;
      padding: 40px 32px;
    }

    header {
      margin-bottom: 48px;
      border-left: 3px solid var(--accent);
      padding-left: 20px;
    }
    header h1 { font-family:'Syne',sans-serif; font-size:28px; font-weight:800; letter-spacing:-0.5px; }
    header p { color:var(--muted); margin-top:6px; font-size:12px; }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .badge-good    { background:rgba(61,232,160,0.15); color:var(--good);    border:1px solid rgba(61,232,160,0.3); }
    .badge-bad     { background:rgba(255,95,109,0.15); color:var(--bad);     border:1px solid rgba(255,95,109,0.3); }
    .badge-muted   { background:rgba(90,97,128,0.2);  color:var(--muted);   border:1px solid rgba(90,97,128,0.3); }
    .badge-pass    { background:rgba(61,232,160,0.15); color:var(--good);    border:1px solid rgba(61,232,160,0.3); }
    .badge-fail    { background:rgba(255,95,109,0.15); color:var(--bad);     border:1px solid rgba(255,95,109,0.3); }
    .badge-gold    { background:rgba(245,200,66,0.15); color:var(--gold);    border:1px solid rgba(245,200,66,0.3); }
    .badge-neutral { background:rgba(74,144,217,0.15); color:var(--neutral); border:1px solid rgba(74,144,217,0.3); }

    section { margin-bottom: 56px; }
    section h2 {
      font-family:'Syne',sans-serif; font-size:13px; font-weight:700;
      text-transform:uppercase; letter-spacing:0.12em; color:var(--muted);
      margin-bottom:20px; display:flex; align-items:center; gap:10px;
    }
    section h2::after { content:''; flex:1; height:1px; background:var(--border); }

    .summary-box {
      background:var(--surface); border:1px solid var(--border); border-radius:8px;
      padding:24px 32px; display:flex; gap:40px; flex-wrap:wrap; align-items:center;
    }
    .summary-stat .num { font-family:'Syne',sans-serif; font-size:34px; font-weight:800; color:var(--accent); }
    .summary-stat .num.gold { color:var(--gold); }
    .summary-stat .lbl { color:var(--muted); font-size:11px; margin-top:2px; }

    .algo-box {
      background:var(--surface2); border:1px solid var(--border);
      border-left:3px solid var(--neutral); border-radius:6px;
      padding:16px 20px; color:var(--muted); font-size:11px; line-height:1.9; margin-bottom:32px;
    }
    .algo-box strong { color:var(--text); }

    .vehicle-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(300px,1fr)); gap:16px; }
    .vehicle-card {
      background:var(--surface); border:1px solid var(--border); border-radius:8px;
      padding:16px; transition:border-color 0.2s;
    }
    .vehicle-card:hover { border-color:var(--accent); }
    .vehicle-card-header { display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px; }
    .vehicle-name { font-family:'Syne',sans-serif; font-weight:700; font-size:13px; }
    .vehicle-meta { color:var(--muted); font-size:11px; margin-top:3px; }

    .heatmap-wrap { overflow-x:auto; }
    .heatmap { border-collapse:collapse; width:100%; margin-top:6px; }
    .heatmap th { color:var(--muted); font-size:9px; font-weight:400; text-align:center; padding:2px 3px; white-space:nowrap; }
    .heatmap td {
      width:14.28%; height:22px; border:1px solid var(--bg); border-radius:2px;
      cursor:default; position:relative;
    }
    .heatmap td:hover::after {
      content:attr(data-tip); position:absolute; bottom:110%; left:50%; transform:translateX(-50%);
      background:#1e2433; border:1px solid var(--border); color:var(--text);
      padding:4px 8px; border-radius:4px; font-size:10px; white-space:nowrap; z-index:10; pointer-events:none;
    }
    .heatmap .row-label { color:var(--muted); font-size:10px; padding-right:6px; white-space:nowrap; width:34px; }

    .rec-list { display:flex; flex-direction:column; gap:20px; }
    .rec-card {
      background:var(--surface); border:1px solid var(--border); border-radius:10px;
      padding:22px 24px; position:relative; overflow:hidden; transition:border-color 0.2s;
    }
    .rec-card:hover { border-color:var(--accent); }
    .rec-card::before { content:''; position:absolute; left:0; top:0; bottom:0; width:3px; }
    .rec-card.tier-gold::before  { background:var(--gold); }
    .rec-card.tier-green::before { background:var(--good); }
    .rec-card.tier-blue::before  { background:var(--neutral); }

    .rec-header { display:flex; align-items:flex-start; justify-content:space-between; gap:16px; flex-wrap:wrap; }
    .rec-title { font-family:'Syne',sans-serif; font-weight:700; font-size:15px; margin-top:6px; }
    .rec-subtitle { color:var(--muted); font-size:11px; margin-top:4px; }

    .rec-savings { text-align:right; flex-shrink:0; }
    .rec-savings .annual { font-family:'Syne',sans-serif; font-size:24px; font-weight:800; color:var(--gold); }
    .rec-savings .detail { color:var(--muted); font-size:10px; margin-top:2px; }
    .rec-savings .total3yr { color:var(--gold); margin-top:4px; font-size:10px; }

    .rec-vehicles { margin-top:14px; display:flex; flex-wrap:wrap; gap:6px; }
    .chip { background:var(--surface2); border:1px solid var(--border); border-radius:4px; padding:3px 10px; font-size:11px; }
    .chip.keep { border-color:var(--good); color:var(--good); }
    .chip.elim { border-color:var(--bad); color:var(--bad); text-decoration:line-through; opacity:0.75; }

    .how-bar {
      margin-top:14px; background:var(--surface2); border:1px solid var(--border);
      border-radius:5px; padding:10px 14px; font-size:11px; color:var(--muted); line-height:1.8;
    }
    .how-bar strong { color:var(--text); }

    .rec-stats { margin-top:16px; display:flex; gap:36px; flex-wrap:wrap; }
    .rec-stat .val { font-family:'Syne',sans-serif; font-size:18px; font-weight:700; }
    .rec-stat .lbl { color:var(--muted); font-size:10px; }

    .pairs-table { width:100%; border-collapse:collapse; }
    .pairs-table th { text-align:left; color:var(--muted); font-size:11px; padding:8px 12px; border-bottom:1px solid var(--border); }
    .pairs-table td { padding:9px 12px; border-bottom:1px solid var(--border); vertical-align:middle; font-size:12px; }
    .pairs-table tr:last-child td { border-bottom:none; }
    .pairs-table tr:hover td { background:rgba(255,255,255,0.02); }
    .pairs-table tr.is-pool td:first-child { border-left:2px solid var(--good); }
    .pairs-table tr.is-conflict td:first-child { border-left:2px solid var(--bad); }

    .bar-wrap { display:flex; align-items:center; gap:8px; }
    .bar { height:5px; border-radius:3px; background:var(--border); width:80px; overflow:hidden; }
    .bar-fill { height:100%; border-radius:3px; }

    .val-list { display:flex; flex-direction:column; gap:10px; }
    .val-item {
      background:var(--surface); border:1px solid var(--border); border-radius:6px;
      padding:12px 16px; display:flex; align-items:center; gap:12px;
    }
    .val-item .check { font-size:16px; flex-shrink:0; }
    .val-item .label { flex:1; }

    .log {
      background:#0a0c0f; border:1px solid var(--border); border-radius:6px;
      padding:16px; font-size:11px; color:var(--muted); max-height:280px; overflow-y:auto; line-height:1.8;
    }
    .log .ok   { color:var(--good); }
    .log .err  { color:var(--bad); }
    .log .info { color:var(--neutral); }
    .log .warn { color:var(--gold); }
  </style>
</head>
<body>

<header>
  <h1>Pool Finder — Logic Validator v5</h1>
  <p>10 vehicles · 1-hour resolution · Graph cliques + merge step · Sum-based elimination · $8–12k/yr op + $7k capital per vehicle removed</p>
</header>

<section>
  <h2>Fleet Summary</h2>
  <div class="summary-box">
    <div class="summary-stat"><div class="num" id="s-vehicles">—</div><div class="lbl">Vehicles</div></div>
    <div class="summary-stat"><div class="num" id="s-trips">—</div><div class="lbl">Total Trips</div></div>
    <div class="summary-stat"><div class="num" id="s-pairs">—</div><div class="lbl">Complementary Pairs</div></div>
    <div class="summary-stat"><div class="num" id="s-groups">—</div><div class="lbl">Pool Groups</div></div>
    <div class="summary-stat"><div class="num" id="s-elim">—</div><div class="lbl">Vehicles Eliminable</div></div>
    <div class="summary-stat"><div class="num gold" id="s-annual">—</div><div class="lbl">Annual Op Savings</div></div>
    <div class="summary-stat"><div class="num gold" id="s-capital">—</div><div class="lbl">Capital Savings</div></div>
  </div>
</section>

<section>
  <h2>Utilization Heatmaps</h2>
  <div class="vehicle-grid" id="heatmap-grid"></div>
</section>

<section>
  <h2>Pool Recommendations — Ranked by 3-Year Value</h2>
  <div class="algo-box">
    <strong>Algorithm v5:</strong>
    (1) Build <strong>1-hour resolution</strong> utilization vectors (168 slots).
    (2) Find complementary pairs: same type + location, cosine overlap ≤ 20%, sum peak ≤ 1.
    (3) Grow pairs into <strong>maximal cliques</strong> (Bron-Kerbosch) — every member complementary to every other.
    (4) <strong>Merge overlapping cliques</strong> that share ≥ 50% of their members — union their vehicle sets into one group.
    (5) Score merged groups: <strong>sum demand vectors</strong> slot-by-slot, peak = max simultaneous vehicles needed.
    Eliminable = group size − ⌈peak⌉. Savings = eliminable × ($10k/yr + $7k capital).
  </div>
  <div class="rec-list" id="rec-list"></div>
</section>

<section>
  <h2>Pair Matrix</h2>
  <table class="pairs-table">
    <thead>
      <tr>
        <th>Vehicle A</th><th>Vehicle B</th><th>Type</th><th>Location</th><th>Cosine Overlap</th><th>Verdict</th>
      </tr>
    </thead>
    <tbody id="pairs-body"></tbody>
  </table>
</section>

<section>
  <h2>Validation — Expected vs Actual</h2>
  <div class="val-list" id="val-list"></div>
</section>

<section>
  <h2>Debug Log</h2>
  <div class="log" id="log"></div>
</section>

<script>
// ═══════════════════════════════════════════════════════════════════
// CONFIG
// ═══════════════════════════════════════════════════════════════════
const CFG = {
  windowDays:          90,
  SLOTS_PER_DAY:       24,
  TOTAL_SLOTS:         168,
  maxOverlapPair:      0.20,   // cosine threshold for complementary pair
  // Merge two cliques if they share this fraction of their combined members
  mergeShareThreshold: 0.50,
  requireSameType:     true,
  requireSameLocation: true,
  annualOpMid:         10000,
  capitalPerVehicle:   7000,
};

const DISPLAY_BLOCKS = ['00–04','04–08','08–12','12–16','16–20','20–24'];
const DAYS = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

// ═══════════════════════════════════════════════════════════════════
// LOGGING
// ═══════════════════════════════════════════════════════════════════
const logEl = document.getElementById('log');
function log(msg, t='info') {
  const d = document.createElement('div');
  d.className = t;
  d.textContent = `› ${msg}`;
  logEl.appendChild(d);
  logEl.scrollTop = logEl.scrollHeight;
}

// ═══════════════════════════════════════════════════════════════════
// TRIP GENERATION  — Geotab shape: { start, stop } ISO strings
// ═══════════════════════════════════════════════════════════════════
function mkTrip(date, sh, eh) {
  const s = new Date(date); s.setHours(sh, 0, 0, 0);
  const e = new Date(date); e.setHours(eh, 0, 0, 0);
  if (e <= s) return null;
  return { start: s.toISOString(), stop: e.toISOString() };
}

function genTrips(fn, days = CFG.windowDays) {
  const out = [], now = new Date();
  for (let i = days; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(d.getDate() - i);
    d.setHours(0, 0, 0, 0);
    fn(d, d.getDay()).forEach(t => { if (t) out.push(t); });
  }
  return out;
}

// ── Patterns: all boundaries are clean hour edges with no shared hours ──
const P = {
  vanDaytime:      (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 8, 17)]  : [],
  vanDaytime2:     (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 8, 17)]  : [], // intentional duplicate
  vanEvening:      (d, dow) => { if(dow>=1&&dow<=5) return[mkTrip(d,17,21)]; if(dow===6) return[mkTrip(d,9,13)]; return[]; },
  vanNight:        (d, dow) => ([0,1,2,3,4].includes(dow)) ? [mkTrip(d, 21, 24)] : [],
  vanEarlyMorn:    (d, dow) => (dow >= 1 && dow <= 6) ? [mkTrip(d, 4, 8)]   : [],
  pickupMorning:   (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 6, 12)]  : [],
  pickupAfternoon: (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 12, 18)] : [],
  sporadic:        (d, dow) => (Math.random() < 0.25) ? [mkTrip(d, 8 + Math.floor(Math.random()*8), 14 + Math.floor(Math.random()*4))] : [],
  depotSouthDay:   (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 8, 17)]  : [],
  depotSouthEvening:(d,dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 17, 22)] : [],
};

// ═══════════════════════════════════════════════════════════════════
// 10 VEHICLES
// ═══════════════════════════════════════════════════════════════════
const VEHICLES = [
  { id:'V01', name:'Van 01 — Facilities', type:'Van',    dept:'Facilities', location:'Depot North', pattern:P.vanDaytime,       note:'Mon–Fri 08:00–17:00' },
  { id:'V02', name:'Van 02 — Admin',      type:'Van',    dept:'Admin',      location:'Depot North', pattern:P.vanDaytime2,      note:'Mon–Fri 08:00–17:00 (same pattern as V01)' },
  { id:'V03', name:'Van 03 — Events',     type:'Van',    dept:'Events',     location:'Depot North', pattern:P.vanEvening,       note:'Mon–Fri 17:00–21:00 + Sat 09:00–13:00' },
  { id:'V04', name:'Van 04 — Security',   type:'Van',    dept:'Security',   location:'Depot North', pattern:P.vanNight,         note:'Sun–Thu 21:00–24:00' },
  { id:'V07', name:'Van 07 — Ops Early',  type:'Van',    dept:'Ops',        location:'Depot North', pattern:P.vanEarlyMorn,     note:'Mon–Sat 04:00–08:00' },
  { id:'P01', name:'Pickup 01 — Field A', type:'Pickup', dept:'Field A',    location:'Depot North', pattern:P.pickupMorning,    note:'Mon–Fri 06:00–12:00' },
  { id:'P02', name:'Pickup 02 — Field B', type:'Pickup', dept:'Field B',    location:'Depot North', pattern:P.pickupAfternoon,  note:'Mon–Fri 12:00–18:00' },
  { id:'S01', name:'Sedan 01 — HR',       type:'Sedan',  dept:'HR',         location:'Depot North', pattern:P.sporadic,         note:'Sporadic ~25% of days' },
  { id:'V05', name:'Van 05 — Logistics A',type:'Van',    dept:'Logistics A',location:'Depot South', pattern:P.depotSouthDay,    note:'Mon–Fri 08:00–17:00' },
  { id:'V06', name:'Van 06 — Logistics B',type:'Van',    dept:'Logistics B',location:'Depot South', pattern:P.depotSouthEvening,note:'Mon–Fri 17:00–22:00' },
];

// ═══════════════════════════════════════════════════════════════════
// CORE: 1-HOUR UTILIZATION VECTOR (168 slots)
// ═══════════════════════════════════════════════════════════════════
function buildVector(trips, windowDays = CFG.windowDays) {
  const wdc = new Array(7).fill(0), now = new Date();
  for (let i = 0; i <= windowDays; i++) {
    const d = new Date(now); d.setDate(d.getDate() - i); wdc[d.getDay()]++;
  }
  const hits = new Array(CFG.TOTAL_SLOTS).fill(0);
  for (const trip of trips) {
    const ts = new Date(trip.start), te = new Date(trip.stop);
    if (te <= ts) continue;
    const cur = new Date(ts); cur.setMinutes(0, 0, 0);
    while (cur < te) {
      const next = new Date(cur); next.setHours(cur.getHours() + 1);
      if (cur < te && next > ts) {
        const idx = cur.getDay() * CFG.SLOTS_PER_DAY + cur.getHours();
        if (idx >= 0 && idx < CFG.TOTAL_SLOTS) hits[idx]++;
      }
      cur.setHours(cur.getHours() + 1);
    }
  }
  return hits.map((h, i) => {
    const day = Math.floor(i / CFG.SLOTS_PER_DAY);
    return wdc[day] > 0 ? Math.min(1, h / wdc[day]) : 0;
  });
}

// ═══════════════════════════════════════════════════════════════════
// CORE: COSINE OVERLAP (0=no overlap, 1=identical)
// ═══════════════════════════════════════════════════════════════════
function cosineOverlap(vA, vB) {
  let dot = 0, mA = 0, mB = 0;
  for (let i = 0; i < vA.length; i++) {
    dot += vA[i] * vB[i]; mA += vA[i] * vA[i]; mB += vB[i] * vB[i];
  }
  const d = Math.sqrt(mA) * Math.sqrt(mB);
  return d === 0 ? 0 : dot / d;
}

// ═══════════════════════════════════════════════════════════════════
// CORE: SUM VECTORS (slot-by-slot addition)
// Peak of sum = max vehicles simultaneously needed
// ═══════════════════════════════════════════════════════════════════
function sumVectors(vecs) {
  return vecs[0].map((_, i) => vecs.reduce((s, v) => s + v[i], 0));
}

function peakOf(sumVec) { return Math.max(...sumVec); }

// ═══════════════════════════════════════════════════════════════════
// CORE: ELIGIBILITY
// ═══════════════════════════════════════════════════════════════════
function pairEligible(vA, vB) {
  if (CFG.requireSameType     && vA.type     !== vB.type)     return false;
  if (CFG.requireSameLocation && vA.location !== vB.location) return false;
  return true;
}

// ═══════════════════════════════════════════════════════════════════
// CORE: SAVINGS
// ═══════════════════════════════════════════════════════════════════
function calcSavings(n) {
  return {
    n,
    annualOp: n * CFG.annualOpMid,
    capital:  n * CFG.capitalPerVehicle,
    total3yr: n * CFG.annualOpMid * 3 + n * CFG.capitalPerVehicle,
  };
}
function fmt(n) { return '$' + Math.round(n).toLocaleString(); }

// ═══════════════════════════════════════════════════════════════════
// ALGORITHM STEP 1: Complementary pairs
// A valid pair must have: same type+location, cosine overlap ≤ threshold,
// AND sum peak ≤ 1 (confirming they genuinely never need to run together)
// ═══════════════════════════════════════════════════════════════════
function findComplementaryPairs(vehicles, vm) {
  const pairs = [];
  const n = vehicles.length;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const vA = vehicles[i], vB = vehicles[j];
      if (!pairEligible(vA, vB)) continue;
      const ol = cosineOverlap(vm[vA.id], vm[vB.id]);
      if (ol > CFG.maxOverlapPair) continue;
      // Confirm with sum: peak must be ≤ 1 (one vehicle can cover both schedules)
      const sumPeak = peakOf(sumVectors([vm[vA.id], vm[vB.id]]));
      if (sumPeak <= 1.0) {
        pairs.push({ idA: vA.id, idB: vB.id, overlap: ol });
        log(`Pair: ${vA.id} × ${vB.id} — overlap ${(ol*100).toFixed(0)}%, sum peak ${sumPeak.toFixed(2)}`, 'ok');
      } else {
        log(`Pair ${vA.id} × ${vB.id}: overlap OK but sum peak ${sumPeak.toFixed(2)} > 1 — skipped`, 'warn');
      }
    }
  }
  return pairs;
}

// ═══════════════════════════════════════════════════════════════════
// ALGORITHM STEP 2: Grow pairs into maximal cliques (Bron-Kerbosch)
// ═══════════════════════════════════════════════════════════════════
function findCliques(vehicles, pairs) {
  const vById = Object.fromEntries(vehicles.map(v => [v.id, v]));
  const adj = {};
  vehicles.forEach(v => { adj[v.id] = new Set(); });
  pairs.forEach(p => { adj[p.idA].add(p.idB); adj[p.idB].add(p.idA); });

  const candidates = vehicles.filter(v => adj[v.id].size > 0).map(v => v.id);
  const cliques = [];

  function bronKerbosch(R, P, X) {
    if (P.length === 0 && X.length === 0) {
      if (R.length >= 2) cliques.push([...R].sort());
      return;
    }
    const pivot = [...P, ...X].reduce((best, v) => {
      const c = P.filter(u => adj[v].has(u)).length;
      return c > best.c ? { v, c } : best;
    }, { v: null, c: -1 }).v;
    const pivotN = pivot ? adj[pivot] : new Set();
    const toProcess = P.filter(v => !pivotN.has(v));
    for (const v of toProcess) {
      const nb = [...adj[v]];
      bronKerbosch([...R, v], P.filter(u => nb.includes(u)), X.filter(u => nb.includes(u)));
      P = P.filter(u => u !== v);
      X = [...X, v];
    }
  }

  bronKerbosch([], candidates, []);
  return cliques.map(ids => ({ ids, members: ids.map(id => vById[id]) }));
}

// ═══════════════════════════════════════════════════════════════════
// ALGORITHM STEP 3: Merge overlapping cliques
//
// Problem: Two cliques like [V01,V03,V04,V07] and [V02,V03,V04,V07]
// share 3 of 4 members. They should be ONE recommendation: a 5-vehicle
// group [V01,V02,V03,V04,V07] where the sum tells us to keep 2 and remove 3.
//
// Strategy: iteratively union any two cliques where:
//   intersection / union >= mergeShareThreshold (default 0.5)
// Repeat until no more merges are possible.
//
// After merging, re-score each merged group with sum-based elimination.
// ═══════════════════════════════════════════════════════════════════
function mergeCliques(cliques, vById) {
  // Work with sets of ids for easy set operations
  let groups = cliques.map(c => new Set(c.ids));

  let merged = true;
  while (merged) {
    merged = false;
    const next = [];

    for (let i = 0; i < groups.length; i++) {
      let absorbed = false;

      for (let j = 0; j < next.length; j++) {
        const intersection = new Set([...groups[i]].filter(id => next[j].has(id)));
        const union        = new Set([...groups[i], ...next[j]]);

        const shareRatio = intersection.size / union.size;

        if (shareRatio >= CFG.mergeShareThreshold) {
          // Merge groups[i] into next[j]
          next[j] = union;
          absorbed = true;
          merged = true;
          log(`Merged cliques — intersection ${intersection.size}/${union.size} (${(shareRatio*100).toFixed(0)}% shared) → group [${[...union].sort().join(',')}]`, 'warn');
          break;
        }
      }

      if (!absorbed) {
        next.push(new Set(groups[i]));
      }
    }

    groups = next;
  }

  // Convert back to structured group objects
  return groups.map(idSet => {
    const ids = [...idSet].sort();
    return { ids, members: ids.map(id => vById[id]) };
  });
}

// ═══════════════════════════════════════════════════════════════════
// ALGORITHM STEP 4: Score merged groups
// ═══════════════════════════════════════════════════════════════════
function scoreGroups(groups, vm) {
  const results = [];

  for (const group of groups) {
    const vecs   = group.members.map(v => vm[v.id]);
    const sumVec = sumVectors(vecs);
    const peak   = peakOf(sumVec);
    const needed = Math.ceil(peak);
    const eliminable = group.members.length - needed;

    if (eliminable < 1) {
      log(`Group [${group.ids.join(',')}]: peak=${peak.toFixed(2)}, needed=${needed} — no elimination possible, skipped`, 'warn');
      continue;
    }

    let olSum = 0, olCount = 0;
    for (let i = 0; i < vecs.length; i++) {
      for (let j = i + 1; j < vecs.length; j++) {
        olSum += cosineOverlap(vecs[i], vecs[j]); olCount++;
      }
    }
    const avgOverlap = olCount > 0 ? olSum / olCount : 0;
    const sv = calcSavings(eliminable);

    results.push({ group, sumVec, peak, needed, eliminable, avgOverlap, savings: sv });
    log(`✓ Group [${group.ids.join(',')}]: size=${group.members.length}, peak=${peak.toFixed(2)}, keep=${needed}, remove=${eliminable}`, 'ok');
  }

  results.sort((a, b) => b.savings.total3yr - a.savings.total3yr);
  return results;
}

// ═══════════════════════════════════════════════════════════════════
// RENDER: HEATMAP (display at 4h blocks, computed at 1h)
// ═══════════════════════════════════════════════════════════════════
function aggregateTo4h(vec1h) {
  const out = [];
  for (let day = 0; day < 7; day++) {
    for (let block = 0; block < 6; block++) {
      let sum = 0;
      for (let h = 0; h < 4; h++) sum += vec1h[day * 24 + block * 4 + h];
      out.push(sum / 4);
    }
  }
  return out;
}

function renderHeatmap(vec1h) {
  const v4 = aggregateTo4h(vec1h);
  const tbl = document.createElement('table'); tbl.className = 'heatmap';
  const hdr = document.createElement('tr');
  const c = document.createElement('th'); c.style.width = '34px'; hdr.appendChild(c);
  DISPLAY_BLOCKS.forEach(b => { const th = document.createElement('th'); th.textContent = b; hdr.appendChild(th); });
  tbl.appendChild(hdr);
  DAYS.forEach((day, di) => {
    const tr = document.createElement('tr');
    const lbl = document.createElement('td'); lbl.className = 'row-label'; lbl.textContent = day; tr.appendChild(lbl);
    for (let b = 0; b < 6; b++) {
      const val = v4[di * 6 + b];
      const td  = document.createElement('td');
      td.style.background = val < 0.05 ? 'rgba(255,255,255,0.03)' : `rgba(61,232,160,${(0.1+val*0.9).toFixed(2)})`;
      td.setAttribute('data-tip', `${day} ${DISPLAY_BLOCKS[b]}: ${(val*100).toFixed(0)}%`);
      tr.appendChild(td);
    }
    tbl.appendChild(tr);
  });
  return tbl;
}

function renderVehicleCard(v, trips, vec) {
  const card = document.createElement('div'); card.className = 'vehicle-card';
  card.innerHTML = `
    <div class="vehicle-card-header">
      <div>
        <div class="vehicle-name">${v.name}</div>
        <div class="vehicle-meta">${v.type} · ${v.dept} · ${v.location}</div>
        <div class="vehicle-meta" style="color:#242840;margin-top:2px">${v.note}</div>
      </div>
      <span class="badge badge-muted">${trips.length} trips</span>
    </div>
  `;
  const w = document.createElement('div'); w.className = 'heatmap-wrap'; w.appendChild(renderHeatmap(vec));
  card.appendChild(w);
  return card;
}

// ═══════════════════════════════════════════════════════════════════
// RENDER: RECOMMENDATION CARD
// ═══════════════════════════════════════════════════════════════════
function renderRecCard(result, rank) {
  const { group, eliminable, needed, peak, avgOverlap, savings } = result;
  const size = group.members.length;

  const tier = eliminable >= 3 ? 'tier-gold' : eliminable >= 2 ? 'tier-green' : 'tier-blue';
  const topBadge = eliminable >= 3
    ? `<span class="badge badge-gold">★ High Value</span>`
    : eliminable >= 2
    ? `<span class="badge badge-good">Strong Opportunity</span>`
    : `<span class="badge badge-neutral">Recommended</span>`;

  // Sort: keep vehicles with lowest utilization variance first (most "schedulable")
  // Simple proxy: keep first `needed` in alphabetical order, mark rest for removal
  const chips = group.members.map((v, i) => {
    const keep = i < needed;
    return `<span class="chip ${keep ? 'keep' : 'elim'}">${keep ? '✓' : '✗'} ${v.name} <span style="font-size:9px;opacity:0.6">(${v.dept})</span></span>`;
  }).join('');

  const card = document.createElement('div');
  card.className = `rec-card ${tier}`;
  card.innerHTML = `
    <div class="rec-header">
      <div>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
          ${topBadge}
          <span class="badge badge-muted">${group.members[0].type} · ${group.members[0].location}</span>
          <span class="badge badge-muted">${size} vehicles → keep ${needed}, remove ${eliminable}</span>
        </div>
        <div class="rec-title">${size} ${group.members[0].type}s form a pool — ${eliminable} can be eliminated</div>
        <div class="rec-subtitle">
          Avg pairwise overlap: ${(avgOverlap*100).toFixed(0)}% ·
          Peak simultaneous demand: ${peak.toFixed(2)} ·
          Min vehicles needed: ${needed}
        </div>
      </div>
      <div class="rec-savings">
        <div class="annual">${fmt(savings.annualOp)}<span style="font-size:13px;color:var(--muted)">/yr</span></div>
        <div class="detail">+ ${fmt(savings.capital)} one-time capital savings</div>
        <div class="total3yr">3-yr total value: ${fmt(savings.total3yr)}</div>
      </div>
    </div>

    <div class="rec-vehicles">${chips}</div>

    <div class="how-bar">
      <strong>Why this works:</strong>
      Summing all ${size} vehicles' hourly demand, the peak never exceeds <strong>${peak.toFixed(2)}</strong>
      simultaneous vehicles. At most <strong>${needed}</strong> vehicle${needed > 1 ? 's are' : ' is'} ever
      needed at the same time — the other <strong>${eliminable}</strong> are safe to remove from the fleet.
      ${eliminable >= 2 ? `<br><strong>Note:</strong> This group was formed by merging cliques that shared vehicles,
      giving a more complete picture than reporting them as separate recommendations.` : ''}
    </div>

    <div class="rec-stats">
      <div class="rec-stat">
        <div class="val">${fmt(savings.annualOp)}</div>
        <div class="lbl">Annual Op Savings<br><span style="color:#2a3060">$8k–$12k/vehicle/yr</span></div>
      </div>
      <div class="rec-stat">
        <div class="val">${fmt(savings.capital)}</div>
        <div class="lbl">Capital Savings<br><span style="color:#2a3060">$7,000/vehicle one-time</span></div>
      </div>
      <div class="rec-stat">
        <div class="val">${fmt(savings.total3yr)}</div>
        <div class="lbl">3-Year Total Value</div>
      </div>
      <div class="rec-stat">
        <div class="val">${eliminable} of ${size}</div>
        <div class="lbl">Vehicles Removed</div>
      </div>
    </div>
  `;
  return card;
}

// ═══════════════════════════════════════════════════════════════════
// RENDER: PAIRS TABLE ROW
// ═══════════════════════════════════════════════════════════════════
function renderPairRow(vA, vB, elig, ol, isComplementary) {
  const tr = document.createElement('tr');
  const tm = vA.type === vB.type, lm = vA.location === vB.location;
  const barColor = !elig ? 'var(--muted)' : isComplementary ? 'var(--good)' : ol >= 0.5 ? 'var(--bad)' : 'var(--neutral)';
  const verdict = !elig
    ? `<span class="badge badge-muted">Ineligible — ${!tm ? 'type' : 'location'} mismatch</span>`
    : isComplementary
    ? `<span class="badge badge-good">✓ Complementary</span>`
    : ol >= 0.5 ? `<span class="badge badge-bad">Conflict</span>`
    : `<span class="badge badge-neutral">Marginal</span>`;
  if (isComplementary) tr.className = 'is-pool';
  else if (elig && ol >= 0.5) tr.className = 'is-conflict';
  tr.innerHTML = `
    <td>${vA.id} — ${vA.dept}</td>
    <td>${vB.id} — ${vB.dept}</td>
    <td><span class="badge ${tm?'badge-pass':'badge-fail'}">${tm?'✓':'✗'} ${vA.type}</span></td>
    <td><span class="badge ${lm?'badge-pass':'badge-fail'}">${lm?'✓ Same':'✗ Diff'}</span></td>
    <td>${elig
      ? `<div class="bar-wrap"><div class="bar"><div class="bar-fill" style="width:${(ol*100).toFixed(1)}%;background:${barColor}"></div></div><span style="color:${barColor};min-width:34px">${(ol*100).toFixed(0)}%</span></div>`
      : '<span style="color:var(--muted)">—</span>'}</td>
    <td>${verdict}</td>
  `;
  return tr;
}

// ═══════════════════════════════════════════════════════════════════
// VALIDATION SUITE — 11 tests
// ═══════════════════════════════════════════════════════════════════
const TESTS = [
  { desc: 'At least 1 actionable pool recommendation found',
    fn: r => r.length >= 1 },

  { desc: 'Every recommendation has eliminable >= 1',
    fn: r => r.length > 0 && r.every(x => x.eliminable >= 1) },

  { desc: 'No duplicate vehicle appears across separate recommendations (deduplication)',
    fn: r => {
      const seen = new Set();
      for (const rec of r) {
        for (const id of rec.group.ids) {
          if (seen.has(id)) return false;
          seen.add(id);
        }
      }
      return true;
    }
  },

  { desc: 'V01 & V02 are in the SAME group (merged — both daytime vans)',
    fn: r => r.some(x => x.group.ids.includes('V01') && x.group.ids.includes('V02')) },

  { desc: 'V01 & V02 group also contains V03, V04, V07 (full shift coverage merged)',
    fn: r => r.some(x =>
      ['V01','V02','V03','V04','V07'].every(id => x.group.ids.includes(id))
    )
  },

  { desc: 'That merged 5-van group keeps 2 and removes 3 (two daytime vans = peak of 2)',
    fn: r => r.some(x =>
      x.group.ids.includes('V01') && x.group.ids.includes('V02') &&
      x.needed === 2 && x.eliminable === 3
    )
  },

  { desc: 'V05 & V06 appear together in a Depot South group',
    fn: r => r.some(x => x.group.ids.includes('V05') && x.group.ids.includes('V06')) },

  { desc: 'P01 & P02 appear in a pickup pool group',
    fn: r => r.some(x => x.group.ids.includes('P01') && x.group.ids.includes('P02')) },

  { desc: 'S01 (Sedan) never appears in any recommendation',
    fn: r => !r.some(x => x.group.ids.includes('S01')) },

  { desc: 'No group mixes Depot North and Depot South',
    fn: r => !r.some(x => {
      const locs = x.group.members.map(v => v.location);
      return locs.includes('Depot North') && locs.includes('Depot South');
    })
  },

  { desc: 'Results sorted by 3-year savings descending',
    fn: r => r.length < 2 || r[0].savings.total3yr >= r[1].savings.total3yr },
];

// ═══════════════════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════════════════
function main() {
  log('Pool Finder v5 — starting', 'info');

  // Build trips & vectors
  const tripMap = {}, vm = {};
  let totalTrips = 0;
  const vById = Object.fromEntries(VEHICLES.map(v => [v.id, v]));

  VEHICLES.forEach(v => {
    const trips = genTrips(v.pattern);
    tripMap[v.id] = trips;
    vm[v.id] = buildVector(trips);
    totalTrips += trips.length;
    log(`${v.id}: ${trips.length} trips built`, 'ok');
  });

  // Heatmaps
  const grid = document.getElementById('heatmap-grid');
  VEHICLES.forEach(v => grid.appendChild(renderVehicleCard(v, tripMap[v.id], vm[v.id])));

  // Step 1: Complementary pairs
  log('--- Step 1: Complementary pairs ---', 'info');
  const pairs = findComplementaryPairs(VEHICLES, vm);
  const pairSet = new Set(pairs.map(p => `${p.idA}+${p.idB}`));
  log(`${pairs.length} complementary pair(s) found`, pairs.length > 0 ? 'ok' : 'err');

  // Pairs matrix
  const tbody = document.getElementById('pairs-body');
  for (let i = 0; i < VEHICLES.length; i++) {
    for (let j = i + 1; j < VEHICLES.length; j++) {
      const vA = VEHICLES[i], vB = VEHICLES[j];
      const elig = pairEligible(vA, vB);
      const ol = elig ? cosineOverlap(vm[vA.id], vm[vB.id]) : 0;
      tbody.appendChild(renderPairRow(vA, vB, elig, ol, pairSet.has(`${vA.id}+${vB.id}`)));
    }
  }

  // Step 2: Clique finding
  log('--- Step 2: Clique finding ---', 'info');
  const cliques = findCliques(VEHICLES, pairs);
  log(`${cliques.length} raw clique(s) found`, cliques.length > 0 ? 'ok' : 'warn');
  cliques.forEach(c => log(`  Clique: [${c.ids.join(', ')}]`, 'info'));

  // Step 3: Merge overlapping cliques
  log('--- Step 3: Merging overlapping cliques ---', 'info');
  const mergedGroups = mergeCliques(cliques, vById);
  log(`${mergedGroups.length} group(s) after merging`, 'ok');
  mergedGroups.forEach(g => log(`  Merged group: [${g.ids.join(', ')}]`, 'info'));

  // Step 4: Score
  log('--- Step 4: Scoring groups ---', 'info');
  const results = scoreGroups(mergedGroups, vm);

  // Render recommendations
  const recList = document.getElementById('rec-list');
  if (!results.length) {
    recList.innerHTML = '<div style="color:var(--muted);padding:20px">No actionable pool groups found.</div>';
  } else {
    results.forEach((r, i) => recList.appendChild(renderRecCard(r, i)));
  }

  // Validation
  log('--- Validation ---', 'info');
  const valList = document.getElementById('val-list');
  let passed = 0;
  TESTS.forEach(t => {
    const ok = (() => { try { return t.fn(results); } catch(e) { return false; } })();
    if (ok) passed++;
    const item = document.createElement('div'); item.className = 'val-item';
    item.innerHTML = `
      <span class="check">${ok ? '✅' : '❌'}</span>
      <div class="label">${t.desc}</div>
      <span class="badge ${ok ? 'badge-pass' : 'badge-fail'}">${ok ? 'PASS' : 'FAIL'}</span>
    `;
    valList.appendChild(item);
    log(`${ok ? 'PASS' : 'FAIL'}: ${t.desc}`, ok ? 'ok' : 'err');
  });

  // Summary — deduplicated (vehicles only counted in their first group)
  const counted = new Set();
  let totalElim = 0, totalAnnual = 0, totalCapital = 0;
  results.forEach(r => {
    if (r.group.ids.every(id => !counted.has(id))) {
      r.group.ids.forEach(id => counted.add(id));
      totalElim    += r.eliminable;
      totalAnnual  += r.savings.annualOp;
      totalCapital += r.savings.capital;
    }
  });

  document.getElementById('s-vehicles').textContent = VEHICLES.length;
  document.getElementById('s-trips').textContent    = totalTrips.toLocaleString();
  document.getElementById('s-pairs').textContent    = pairs.length;
  document.getElementById('s-groups').textContent   = results.length;
  document.getElementById('s-elim').textContent     = totalElim;
  document.getElementById('s-annual').textContent   = fmt(totalAnnual);
  document.getElementById('s-capital').textContent  = fmt(totalCapital);

  log(`Done — ${passed}/${TESTS.length} tests passed · ${totalElim} eliminable · ${fmt(totalAnnual)}/yr`, passed === TESTS.length ? 'ok' : 'warn');
}

main();
</script>
</body>
</html>
