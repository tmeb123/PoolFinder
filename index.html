<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pool Finder</title>
</head>
<body>

<!--
  SHADOW DOM ISOLATION
  ====================
  MyGeotab custom page add-ins inject HTML directly into their own DOM,
  meaning Geotab's stylesheet overrides everything we write. The only
  bulletproof solution is Shadow DOM: a hard browser-enforced boundary
  where our CSS is completely invisible to the host page and vice versa.

  How it works:
    1. We place a single empty <div id="pf-host"> in the body.
    2. JS attaches a shadow root to it (mode:'open').
    3. All our HTML + CSS lives inside that shadow root.
    4. Geotab's CSS cannot cross the shadow boundary. Ever.
-->
<div id="pf-host"></div>

<script>
// ─────────────────────────────────────────────────────────────────────────────
// SHADOW ROOT SETUP — inject all HTML + CSS into an isolated shadow DOM
// ─────────────────────────────────────────────────────────────────────────────
const host = document.getElementById('pf-host');
const shadow = host.attachShadow({ mode: 'open' });

// All CSS lives here — completely isolated from MyGeotab's styles
const style = document.createElement('style');
style.textContent = `
  /* ── Reset (safe — only affects shadow DOM) ── */
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  /* ── Tokens ── */
  :host {
    display: block;
    --blue:      #0075C9;
    --blue-dark: #005a9e;
    --blue-lt:   #e8f4fd;
    --green:     #1a7f4b;
    --green-lt:  #e6f4ec;
    --red:       #c0392b;
    --red-lt:    #fdf0ee;
    --gold:      #b45309;
    --gold-lt:   #fef3c7;
    --gray-50:   #f8f9fa;
    --gray-100:  #f1f3f5;
    --gray-200:  #e9ecef;
    --gray-300:  #dee2e6;
    --gray-500:  #868e96;
    --gray-700:  #495057;
    --gray-900:  #212529;
    --white:     #ffffff;
    --radius:    6px;
    --shadow:    0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
    --shadow-md: 0 4px 12px rgba(0,0,0,0.10);
  }

  .app {
    background: var(--gray-50);
    color: var(--gray-900);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
    max-width: 1200px;
    margin: 0 auto;
    padding: 24px 20px 60px;
  }

  /* ── Header ── */
  .app-header {
    display: flex;
    align-items: center;
    gap: 14px;
    padding: 20px 24px;
    background: var(--white);
    border-bottom: 3px solid var(--blue);
    border-radius: var(--radius) var(--radius) 0 0;
    box-shadow: var(--shadow);
    margin-bottom: 24px;
  }
  .logo {
    width: 40px; height: 40px;
    background: var(--blue);
    border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
  }
  .logo svg { fill: white; width: 22px; height: 22px; }
  .app-header h1 {
    font-size: 20px;
    font-weight: 700;
    color: var(--gray-900);
    letter-spacing: -0.3px;
  }
  .app-header p { font-size: 12px; color: var(--gray-500); margin-top: 2px; }

  /* ── Section ── */
  .section { margin-bottom: 28px; }
  .section-title {
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--gray-500);
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .section-title::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--gray-200);
  }

  /* ── Summary bar ── */
  .summary-bar {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    margin-bottom: 28px;
  }
  .stat-card {
    background: var(--white);
    border: 1px solid var(--gray-200);
    border-radius: var(--radius);
    padding: 16px 20px;
    box-shadow: var(--shadow);
  }
  .stat-card .num {
    font-size: 28px;
    font-weight: 800;
    color: var(--blue);
    line-height: 1;
  }
  .stat-card .num.green { color: var(--green); }
  .stat-card .num.gold  { color: var(--gold); }
  .stat-card .lbl {
    font-size: 11px;
    color: var(--gray-500);
    margin-top: 4px;
    font-weight: 500;
  }

  /* ── Rec cards ── */
  .rec-list { display: flex; flex-direction: column; gap: 16px; }
  .rec-card {
    background: var(--white);
    border: 1px solid var(--gray-200);
    border-left: 4px solid var(--blue);
    border-radius: var(--radius);
    padding: 20px 24px;
    box-shadow: var(--shadow);
  }
  .rec-card.high-value { border-left-color: var(--gold); }
  .rec-card.strong     { border-left-color: var(--green); }

  .rec-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 16px;
  }
  .rec-badges { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; }

  /* ── Badges ── */
  .badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.04em;
  }
  .badge-blue    { background: var(--blue-lt);  color: var(--blue-dark); }
  .badge-green   { background: var(--green-lt); color: var(--green); }
  .badge-red     { background: var(--red-lt);   color: var(--red); }
  .badge-gold    { background: var(--gold-lt);  color: var(--gold); }
  .badge-gray    { background: var(--gray-100); color: var(--gray-700); }
  .badge-pass    { background: var(--green-lt); color: var(--green); }
  .badge-fail    { background: var(--red-lt);   color: var(--red); }
  .badge-good    { background: var(--green-lt); color: var(--green); }
  .badge-bad     { background: var(--red-lt);   color: var(--red); }
  .badge-neutral { background: var(--gray-100); color: var(--gray-700); }

  .rec-title { font-size: 16px; font-weight: 700; color: var(--gray-900); }
  .rec-meta  { font-size: 12px; color: var(--gray-500); margin-top: 4px; }

  .rec-savings { text-align: right; flex-shrink: 0; }
  .rec-savings .big {
    font-size: 26px; font-weight: 800; color: var(--green); line-height: 1;
  }
  .rec-savings .sub   { font-size: 11px; color: var(--gray-500); margin-top: 4px; }
  .rec-savings .total { font-size: 12px; font-weight: 600; color: var(--gold); margin-top: 3px; }

  /* ── Chips ── */
  .chip-row { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 14px; }
  .chip {
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
    border: 1px solid;
    display: inline-block;
  }
  .chip-keep { background: var(--green-lt); color: var(--green); border-color: #a7d7bc; }
  .chip-elim { background: var(--red-lt); color: var(--red); border-color: #f0b8b2; text-decoration: line-through; opacity: 0.85; }

  /* ── Why box ── */
  .why-box {
    margin-top: 14px;
    background: var(--gray-50);
    border: 1px solid var(--gray-200);
    border-radius: 4px;
    padding: 10px 14px;
    font-size: 12px;
    color: var(--gray-700);
    line-height: 1.7;
  }

  /* ── Savings row ── */
  .savings-row {
    display: flex;
    flex-wrap: wrap;
    gap: 24px;
    margin-top: 14px;
    padding-top: 14px;
    border-top: 1px solid var(--gray-200);
  }
  .savings-item .val { font-size: 18px; font-weight: 700; color: var(--gray-900); }
  .savings-item .lbl { font-size: 11px; color: var(--gray-500); }

  /* ── Vehicle grid ── */
  .vehicle-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 12px;
  }
  .vehicle-card {
    background: var(--white);
    border: 1px solid var(--gray-200);
    border-radius: var(--radius);
    padding: 14px 16px;
    box-shadow: var(--shadow);
  }
  .vehicle-card-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 10px;
  }
  .vehicle-name { font-size: 13px; font-weight: 700; color: var(--gray-900); }
  .vehicle-meta { font-size: 11px; color: var(--gray-500); margin-top: 2px; }

  /* ── Heatmap ── */
  .heatmap { border-collapse: collapse; width: 100%; }
  .heatmap th {
    font-size: 9px; font-weight: 600; color: var(--gray-500);
    text-align: center; padding: 2px 1px; letter-spacing: 0.02em;
  }
  .heatmap .row-label {
    font-size: 10px; color: var(--gray-500);
    padding-right: 6px; white-space: nowrap; font-weight: 500;
  }
  .heatmap td.cell {
    height: 20px;
    border: 1px solid var(--gray-100);
    border-radius: 2px;
    cursor: default;
    position: relative;
  }
  .heatmap td.cell:hover::after {
    content: attr(data-tip);
    position: absolute;
    bottom: 110%; left: 50%; transform: translateX(-50%);
    background: var(--gray-900); color: white;
    padding: 3px 7px; border-radius: 3px;
    font-size: 10px; white-space: nowrap;
    z-index: 100; pointer-events: none;
  }

  /* ── Pairs table ── */
  .data-table {
    width: 100%; border-collapse: collapse;
    background: var(--white);
    border-radius: var(--radius); overflow: hidden;
    box-shadow: var(--shadow);
  }
  .data-table th {
    background: var(--gray-50);
    border-bottom: 2px solid var(--gray-200);
    text-align: left; padding: 10px 14px;
    font-size: 11px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 0.06em;
    color: var(--gray-500);
  }
  .data-table td {
    padding: 9px 14px;
    border-bottom: 1px solid var(--gray-100);
    font-size: 13px; vertical-align: middle;
  }
  .data-table tr:last-child td { border-bottom: none; }
  .data-table tr:hover td { background: var(--gray-50); }
  .data-table tr.pool-row td:first-child     { border-left: 3px solid var(--green); }
  .data-table tr.conflict-row td:first-child { border-left: 3px solid var(--red); }

  .bar-wrap { display: flex; align-items: center; gap: 8px; }
  .bar { height: 6px; border-radius: 3px; background: var(--gray-200); width: 80px; overflow: hidden; }
  .bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }

  /* ── Validation ── */
  .val-list { display: flex; flex-direction: column; gap: 8px; }
  .val-item {
    display: flex; align-items: center; gap: 12px;
    background: var(--white);
    border: 1px solid var(--gray-200);
    border-radius: var(--radius);
    padding: 10px 14px; font-size: 13px;
  }
  .val-item .check { font-size: 16px; flex-shrink: 0; }
  .val-item .label { flex: 1; color: var(--gray-700); }

  /* ── Log ── */
  .log {
    background: var(--gray-900);
    border-radius: var(--radius);
    padding: 16px;
    font-family: "Consolas", "Courier New", monospace;
    font-size: 11px; color: #adb5bd;
    max-height: 220px; overflow-y: auto; line-height: 1.8;
  }
  .log .ok   { color: #69db7c; display: block; }
  .log .err  { color: #ff6b6b; display: block; }
  .log .info { color: #74c0fc; display: block; }
  .log .warn { color: #ffd43b; display: block; }

  /* ── Loading ── */
  .loading { text-align: center; padding: 60px 20px; color: var(--gray-500); }
  .spinner {
    width: 32px; height: 32px;
    border: 3px solid var(--gray-200);
    border-top-color: var(--blue);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin: 0 auto 16px;
    display: block;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* ── Responsive ── */
  @media (max-width: 600px) {
    .app { padding: 12px 12px 40px; }
    .rec-top { flex-direction: column; }
    .rec-savings { text-align: left; }
    .summary-bar { grid-template-columns: repeat(2, 1fr); }
  }
`;
shadow.appendChild(style);

// ── Build the HTML inside the shadow root ──
const app = document.createElement('div');
app.className = 'app';
app.innerHTML = `
  <!-- Header -->
  <div class="app-header">
    <div class="logo">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M18 4H6C4.9 4 4 4.9 4 6v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11h-2v-4H9l3-5 3 5h-2v4z"/>
      </svg>
    </div>
    <div>
      <h1>Pool Finder</h1>
      <p>Fleet vehicle pool optimizer · Identify underutilized vehicles for consolidation · Savings model: $8–12k/yr operating + $7k capital per vehicle removed</p>
    </div>
  </div>

  <!-- Summary -->
  <div class="section">
    <div class="section-title">Fleet Summary</div>
    <div class="summary-bar">
      <div class="stat-card"><div class="num" id="s-vehicles">—</div><div class="lbl">Vehicles Analyzed</div></div>
      <div class="stat-card"><div class="num" id="s-trips">—</div><div class="lbl">Total Trips</div></div>
      <div class="stat-card"><div class="num" id="s-pairs">—</div><div class="lbl">Complementary Pairs</div></div>
      <div class="stat-card"><div class="num" id="s-groups">—</div><div class="lbl">Pool Opportunities</div></div>
      <div class="stat-card"><div class="num green" id="s-elim">—</div><div class="lbl">Vehicles Eliminable</div></div>
      <div class="stat-card"><div class="num gold" id="s-annual">—</div><div class="lbl">Annual Op Savings</div></div>
      <div class="stat-card"><div class="num gold" id="s-capital">—</div><div class="lbl">Capital Savings (one-time)</div></div>
    </div>
  </div>

  <!-- Recommendations -->
  <div class="section">
    <div class="section-title">Pool Recommendations — Ranked by 3-Year Value</div>
    <div class="rec-list" id="rec-list">
      <div class="loading"><div class="spinner"></div>Analyzing fleet utilization patterns…</div>
    </div>
  </div>

  <!-- Heatmaps -->
  <div class="section">
    <div class="section-title">Utilization Heatmaps — All Vehicles</div>
    <div class="vehicle-grid" id="heatmap-grid"></div>
  </div>

  <!-- Pairs matrix -->
  <div class="section">
    <div class="section-title">Pair Compatibility Matrix</div>
    <div style="overflow-x:auto">
      <table class="data-table">
        <thead>
          <tr>
            <th>Vehicle A</th><th>Vehicle B</th><th>Type</th><th>Location</th><th>Overlap</th><th>Verdict</th>
          </tr>
        </thead>
        <tbody id="pairs-body"></tbody>
      </table>
    </div>
  </div>

  <!-- Validation -->
  <div class="section">
    <div class="section-title">Logic Validation</div>
    <div class="val-list" id="val-list"></div>
  </div>

  <!-- Log -->
  <div class="section">
    <div class="section-title">Debug Log</div>
    <div class="log" id="log"></div>
  </div>
`;
shadow.appendChild(app);

// ─────────────────────────────────────────────────────────────────────────────
// IMPORTANT: All getElementById calls must query inside the shadow root,
// not document — because our elements live in the shadow DOM, not the main DOM.
// ─────────────────────────────────────────────────────────────────────────────
function $(id) { return shadow.getElementById(id); }

// ═══════════════════════════════════════════════════════════════════
// CONFIG
// ═══════════════════════════════════════════════════════════════════
const CFG = {
  windowDays:          90,
  SLOTS_PER_DAY:       24,
  TOTAL_SLOTS:         168,
  maxOverlapPair:      0.20,
  mergeShareThreshold: 0.50,
  requireSameType:     true,
  requireSameLocation: true,
  annualOpMid:         10000,
  capitalPerVehicle:   7000,
};

const DISPLAY_BLOCKS = ['00–04','04–08','08–12','12–16','16–20','20–24'];
const DAYS = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

// ═══════════════════════════════════════════════════════════════════
// LOGGING
// ═══════════════════════════════════════════════════════════════════
const logEl = $('log');
function log(msg, t='info') {
  const d = document.createElement('div');
  d.className = t;
  d.textContent = `› ${msg}`;
  logEl.appendChild(d);
  logEl.scrollTop = logEl.scrollHeight;
}

// ═══════════════════════════════════════════════════════════════════
// TRIP GENERATION
// ═══════════════════════════════════════════════════════════════════
function mkTrip(date, sh, eh) {
  const s = new Date(date); s.setHours(sh, 0, 0, 0);
  const e = new Date(date); e.setHours(eh, 0, 0, 0);
  if (e <= s) return null;
  return { start: s.toISOString(), stop: e.toISOString() };
}

function genTrips(fn, days = CFG.windowDays) {
  const out = [], now = new Date();
  for (let i = days; i >= 0; i--) {
    const d = new Date(now);
    d.setDate(d.getDate() - i);
    d.setHours(0, 0, 0, 0);
    fn(d, d.getDay()).forEach(t => { if (t) out.push(t); });
  }
  return out;
}

const P = {
  vanDaytime:       (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 8, 17)]  : [],
  vanDaytime2:      (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 8, 17)]  : [],
  vanEvening:       (d, dow) => { if(dow>=1&&dow<=5) return[mkTrip(d,17,21)]; if(dow===6) return[mkTrip(d,9,13)]; return[]; },
  vanNight:         (d, dow) => ([0,1,2,3,4].includes(dow)) ? [mkTrip(d, 21, 24)] : [],
  vanEarlyMorn:     (d, dow) => (dow >= 1 && dow <= 6) ? [mkTrip(d, 4, 8)]   : [],
  pickupMorning:    (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 6, 12)]  : [],
  pickupAfternoon:  (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 12, 18)] : [],
  sporadic:         (d, dow) => (Math.random() < 0.25) ? [mkTrip(d, 8 + Math.floor(Math.random()*8), 14 + Math.floor(Math.random()*4))] : [],
  depotSouthDay:    (d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 8, 17)]  : [],
  depotSouthEvening:(d, dow) => (dow >= 1 && dow <= 5) ? [mkTrip(d, 17, 22)] : [],
};

// ═══════════════════════════════════════════════════════════════════
// VEHICLES
// ═══════════════════════════════════════════════════════════════════
const VEHICLES = [
  { id:'V01', name:'Van 01 — Facilities', type:'Van',    dept:'Facilities', location:'Depot North', pattern:P.vanDaytime,       note:'Mon–Fri 08:00–17:00' },
  { id:'V02', name:'Van 02 — Admin',      type:'Van',    dept:'Admin',      location:'Depot North', pattern:P.vanDaytime2,      note:'Mon–Fri 08:00–17:00 (same pattern as V01)' },
  { id:'V03', name:'Van 03 — Events',     type:'Van',    dept:'Events',     location:'Depot North', pattern:P.vanEvening,       note:'Mon–Fri 17:00–21:00 + Sat 09:00–13:00' },
  { id:'V04', name:'Van 04 — Security',   type:'Van',    dept:'Security',   location:'Depot North', pattern:P.vanNight,         note:'Sun–Thu 21:00–24:00' },
  { id:'V07', name:'Van 07 — Ops Early',  type:'Van',    dept:'Ops',        location:'Depot North', pattern:P.vanEarlyMorn,     note:'Mon–Sat 04:00–08:00' },
  { id:'P01', name:'Pickup 01 — Field A', type:'Pickup', dept:'Field A',    location:'Depot North', pattern:P.pickupMorning,    note:'Mon–Fri 06:00–12:00' },
  { id:'P02', name:'Pickup 02 — Field B', type:'Pickup', dept:'Field B',    location:'Depot North', pattern:P.pickupAfternoon,  note:'Mon–Fri 12:00–18:00' },
  { id:'S01', name:'Sedan 01 — HR',       type:'Sedan',  dept:'HR',         location:'Depot North', pattern:P.sporadic,         note:'Sporadic ~25% of days' },
  { id:'V05', name:'Van 05 — Logistics A',type:'Van',    dept:'Logistics A',location:'Depot South', pattern:P.depotSouthDay,    note:'Mon–Fri 08:00–17:00' },
  { id:'V06', name:'Van 06 — Logistics B',type:'Van',    dept:'Logistics B',location:'Depot South', pattern:P.depotSouthEvening,note:'Mon–Fri 17:00–22:00' },
];

// ═══════════════════════════════════════════════════════════════════
// CORE ALGORITHMS
// ═══════════════════════════════════════════════════════════════════
function buildVector(trips, windowDays = CFG.windowDays) {
  const wdc = new Array(7).fill(0), now = new Date();
  for (let i = 0; i <= windowDays; i++) {
    const d = new Date(now); d.setDate(d.getDate() - i); wdc[d.getDay()]++;
  }
  const hits = new Array(CFG.TOTAL_SLOTS).fill(0);
  for (const trip of trips) {
    const ts = new Date(trip.start), te = new Date(trip.stop);
    if (te <= ts) continue;
    const cur = new Date(ts); cur.setMinutes(0, 0, 0);
    while (cur < te) {
      const next = new Date(cur); next.setHours(cur.getHours() + 1);
      if (cur < te && next > ts) {
        const idx = cur.getDay() * CFG.SLOTS_PER_DAY + cur.getHours();
        if (idx >= 0 && idx < CFG.TOTAL_SLOTS) hits[idx]++;
      }
      cur.setHours(cur.getHours() + 1);
    }
  }
  return hits.map((h, i) => {
    const day = Math.floor(i / CFG.SLOTS_PER_DAY);
    return wdc[day] > 0 ? Math.min(1, h / wdc[day]) : 0;
  });
}

function cosineOverlap(vA, vB) {
  let dot = 0, mA = 0, mB = 0;
  for (let i = 0; i < vA.length; i++) {
    dot += vA[i] * vB[i]; mA += vA[i] * vA[i]; mB += vB[i] * vB[i];
  }
  const d = Math.sqrt(mA) * Math.sqrt(mB);
  return d === 0 ? 0 : dot / d;
}

function sumVectors(vecs) {
  return vecs[0].map((_, i) => vecs.reduce((s, v) => s + v[i], 0));
}
function peakOf(sumVec) { return Math.max(...sumVec); }

function pairEligible(vA, vB) {
  if (CFG.requireSameType     && vA.type     !== vB.type)     return false;
  if (CFG.requireSameLocation && vA.location !== vB.location) return false;
  return true;
}

function calcSavings(n) {
  return {
    n,
    annualOp: n * CFG.annualOpMid,
    capital:  n * CFG.capitalPerVehicle,
    total3yr: n * CFG.annualOpMid * 3 + n * CFG.capitalPerVehicle,
  };
}
function fmt(n) { return '$' + Math.round(n).toLocaleString(); }

function findComplementaryPairs(vehicles, vm) {
  const pairs = [];
  const n = vehicles.length;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const vA = vehicles[i], vB = vehicles[j];
      if (!pairEligible(vA, vB)) continue;
      const ol = cosineOverlap(vm[vA.id], vm[vB.id]);
      if (ol > CFG.maxOverlapPair) continue;
      const sumPeak = peakOf(sumVectors([vm[vA.id], vm[vB.id]]));
      if (sumPeak <= 1.0) {
        pairs.push({ idA: vA.id, idB: vB.id, overlap: ol });
        log(`Pair: ${vA.id} × ${vB.id} — overlap ${(ol*100).toFixed(0)}%, sum peak ${sumPeak.toFixed(2)}`, 'ok');
      } else {
        log(`Pair ${vA.id} × ${vB.id}: overlap OK but sum peak ${sumPeak.toFixed(2)} > 1 — skipped`, 'warn');
      }
    }
  }
  return pairs;
}

function findCliques(vehicles, pairs) {
  const vById = Object.fromEntries(vehicles.map(v => [v.id, v]));
  const adj = {};
  vehicles.forEach(v => { adj[v.id] = new Set(); });
  pairs.forEach(p => { adj[p.idA].add(p.idB); adj[p.idB].add(p.idA); });
  const candidates = vehicles.filter(v => adj[v.id].size > 0).map(v => v.id);
  const cliques = [];
  function bronKerbosch(R, P, X) {
    if (P.length === 0 && X.length === 0) {
      if (R.length >= 2) cliques.push([...R].sort());
      return;
    }
    const pivot = [...P, ...X].reduce((best, v) => {
      const c = P.filter(u => adj[v].has(u)).length;
      return c > best.c ? { v, c } : best;
    }, { v: null, c: -1 }).v;
    const pivotN = pivot ? adj[pivot] : new Set();
    const toProcess = P.filter(v => !pivotN.has(v));
    for (const v of toProcess) {
      const nb = [...adj[v]];
      bronKerbosch([...R, v], P.filter(u => nb.includes(u)), X.filter(u => nb.includes(u)));
      P = P.filter(u => u !== v);
      X = [...X, v];
    }
  }
  bronKerbosch([], candidates, []);
  return cliques.map(ids => ({ ids, members: ids.map(id => vById[id]) }));
}

function mergeCliques(cliques, vById) {
  let groups = cliques.map(c => new Set(c.ids));
  let merged = true;
  while (merged) {
    merged = false;
    const next = [];
    for (let i = 0; i < groups.length; i++) {
      let absorbed = false;
      for (let j = 0; j < next.length; j++) {
        const intersection = new Set([...groups[i]].filter(id => next[j].has(id)));
        const union        = new Set([...groups[i], ...next[j]]);
        const shareRatio = intersection.size / union.size;
        if (shareRatio >= CFG.mergeShareThreshold) {
          next[j] = union; absorbed = true; merged = true;
          log(`Merged cliques — intersection ${intersection.size}/${union.size} (${(shareRatio*100).toFixed(0)}% shared) → group [${[...union].sort().join(',')}]`, 'warn');
          break;
        }
      }
      if (!absorbed) next.push(new Set(groups[i]));
    }
    groups = next;
  }
  return groups.map(idSet => {
    const ids = [...idSet].sort();
    return { ids, members: ids.map(id => vById[id]) };
  });
}

function scoreGroups(groups, vm) {
  const results = [];
  for (const group of groups) {
    const vecs = group.members.map(v => vm[v.id]);
    const sumVec = sumVectors(vecs);
    const peak = peakOf(sumVec);
    const needed = Math.ceil(peak);
    const eliminable = group.members.length - needed;
    if (eliminable < 1) {
      log(`Group [${group.ids.join(',')}]: peak=${peak.toFixed(2)}, needed=${needed} — no elimination possible, skipped`, 'warn');
      continue;
    }
    let olSum = 0, olCount = 0;
    for (let i = 0; i < vecs.length; i++)
      for (let j = i + 1; j < vecs.length; j++) { olSum += cosineOverlap(vecs[i], vecs[j]); olCount++; }
    const avgOverlap = olCount > 0 ? olSum / olCount : 0;
    const sv = calcSavings(eliminable);
    results.push({ group, sumVec, peak, needed, eliminable, avgOverlap, savings: sv });
    log(`✓ Group [${group.ids.join(',')}]: size=${group.members.length}, peak=${peak.toFixed(2)}, keep=${needed}, remove=${eliminable}`, 'ok');
  }
  results.sort((a, b) => b.savings.total3yr - a.savings.total3yr);
  return results;
}

// ═══════════════════════════════════════════════════════════════════
// RENDER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════
function aggregateTo4h(vec1h) {
  const out = [];
  for (let day = 0; day < 7; day++)
    for (let block = 0; block < 6; block++) {
      let sum = 0;
      for (let h = 0; h < 4; h++) sum += vec1h[day * 24 + block * 4 + h];
      out.push(sum / 4);
    }
  return out;
}

function renderHeatmap(vec1h) {
  const v4 = aggregateTo4h(vec1h);
  const tbl = document.createElement('table'); tbl.className = 'heatmap';
  const hdr = document.createElement('tr');
  const c = document.createElement('th'); c.style.width = '34px'; hdr.appendChild(c);
  DISPLAY_BLOCKS.forEach(b => { const th = document.createElement('th'); th.textContent = b; hdr.appendChild(th); });
  tbl.appendChild(hdr);
  DAYS.forEach((day, di) => {
    const tr = document.createElement('tr');
    const lbl = document.createElement('td'); lbl.className = 'row-label'; lbl.textContent = day; tr.appendChild(lbl);
    for (let b = 0; b < 6; b++) {
      const val = v4[di * 6 + b];
      const td  = document.createElement('td'); td.className = 'cell';
      if (val < 0.05) td.style.background = '#f8f9fa';
      else if (val < 0.4) td.style.background = `rgba(0,117,201,${(0.15+val*0.5).toFixed(2)})`;
      else td.style.background = `rgba(0,117,201,${(0.4+val*0.55).toFixed(2)})`;
      td.setAttribute('data-tip', `${day} ${DISPLAY_BLOCKS[b]}: ${(val*100).toFixed(0)}%`);
      tr.appendChild(td);
    }
    tbl.appendChild(tr);
  });
  return tbl;
}

function renderVehicleCard(v, trips, vec) {
  const card = document.createElement('div'); card.className = 'vehicle-card';
  card.innerHTML = `
    <div class="vehicle-card-top">
      <div>
        <div class="vehicle-name">${v.name}</div>
        <div class="vehicle-meta">${v.type} · ${v.dept} · ${v.location}</div>
        <div class="vehicle-meta">${v.note}</div>
      </div>
      <span class="badge badge-gray">${trips.length} trips</span>
    </div>
  `;
  const w = document.createElement('div'); w.className = 'heatmap-wrap'; w.appendChild(renderHeatmap(vec));
  card.appendChild(w);
  return card;
}

function renderRecCard(result, rank) {
  const { group, eliminable, needed, peak, avgOverlap, savings } = result;
  const size = group.members.length;
  const tier = eliminable >= 3 ? 'high-value' : eliminable >= 2 ? 'strong' : '';
  const topBadge = eliminable >= 3
    ? `<span class="badge badge-gold">★ High Value</span>`
    : eliminable >= 2
    ? `<span class="badge badge-green">Strong Opportunity</span>`
    : `<span class="badge badge-blue">Recommended</span>`;
  const chips = group.members.map((v, i) => {
    const keep = i < needed;
    return `<span class="chip ${keep ? 'chip-keep' : 'chip-elim'}">${keep ? '✓ Keep:' : '✗ Remove:'} ${v.name} (${v.dept})</span>`;
  }).join('');
  const card = document.createElement('div');
  card.className = `rec-card ${tier}`;
  card.innerHTML = `
    <div class="rec-top">
      <div>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
          ${topBadge}
          <span class="badge badge-gray">${group.members[0].type} · ${group.members[0].location}</span>
          <span class="badge badge-gray">${size} vehicles → keep ${needed}, remove ${eliminable}</span>
        </div>
        <div class="rec-title">${size} ${group.members[0].type}s form a pool — ${eliminable} can be eliminated</div>
        <div class="rec-meta">
          Avg pairwise overlap: ${(avgOverlap*100).toFixed(0)}% ·
          Peak simultaneous demand: ${peak.toFixed(2)} ·
          Min vehicles needed: ${needed}
        </div>
      </div>
      <div class="rec-savings">
        <div class="big">${fmt(savings.annualOp)}<span style="font-size:13px;color:#868e96">/yr</span></div>
        <div class="sub">+ ${fmt(savings.capital)} one-time capital savings</div>
        <div class="total">3-yr total value: ${fmt(savings.total3yr)}</div>
      </div>
    </div>
    <div class="chip-row">${chips}</div>
    <div class="why-box">
      <strong>Why this works:</strong>
      Summing all ${size} vehicles' hourly demand, the peak never exceeds <strong>${peak.toFixed(2)}</strong>
      simultaneous vehicles. At most <strong>${needed}</strong> vehicle${needed > 1 ? 's are' : ' is'} ever
      needed at the same time — the other <strong>${eliminable}</strong> are safe to remove from the fleet.
      ${eliminable >= 2 ? `<br><strong>Note:</strong> This group was formed by merging cliques that shared vehicles, giving a more complete picture than reporting them as separate recommendations.` : ''}
    </div>
    <div class="savings-row">
      <div class="savings-item">
        <div class="val">${fmt(savings.annualOp)}</div>
        <div class="lbl">Annual Op Savings<br><span style="color:#2a3060">$8k–$12k/vehicle/yr</span></div>
      </div>
      <div class="savings-item">
        <div class="val">${fmt(savings.capital)}</div>
        <div class="lbl">Capital Savings<br><span style="color:#2a3060">$7,000/vehicle one-time</span></div>
      </div>
      <div class="savings-item">
        <div class="val">${fmt(savings.total3yr)}</div>
        <div class="lbl">3-Year Total Value</div>
      </div>
      <div class="savings-item">
        <div class="val">${eliminable} of ${size}</div>
        <div class="lbl">Vehicles Removed</div>
      </div>
    </div>
  `;
  return card;
}

function renderPairRow(vA, vB, elig, ol, isComplementary) {
  const tr = document.createElement('tr');
  const tm = vA.type === vB.type, lm = vA.location === vB.location;
  const barColor = !elig ? '#868e96' : isComplementary ? '#1a7f4b' : ol >= 0.5 ? '#c0392b' : '#0075C9';
  const verdict = !elig
    ? `<span class="badge badge-gray">Ineligible — ${!tm ? 'type' : 'location'} mismatch</span>`
    : isComplementary
    ? `<span class="badge badge-good">✓ Complementary</span>`
    : ol >= 0.5 ? `<span class="badge badge-bad">Conflict</span>`
    : `<span class="badge badge-neutral">Marginal</span>`;
  if (isComplementary) tr.className = 'pool-row';
  else if (elig && ol >= 0.5) tr.className = 'conflict-row';
  tr.innerHTML = `
    <td>${vA.id} — ${vA.dept}</td>
    <td>${vB.id} — ${vB.dept}</td>
    <td><span class="badge ${tm?'badge-pass':'badge-fail'}">${tm?'✓':'✗'} ${vA.type}</span></td>
    <td><span class="badge ${lm?'badge-pass':'badge-fail'}">${lm?'✓ Same':'✗ Diff'}</span></td>
    <td>${elig
      ? `<div class="bar-wrap"><div class="bar"><div class="bar-fill" style="width:${(ol*100).toFixed(1)}%;background:${barColor}"></div></div><span style="color:${barColor};min-width:34px">${(ol*100).toFixed(0)}%</span></div>`
      : '<span style="color:#868e96">—</span>'}</td>
    <td>${verdict}</td>
  `;
  return tr;
}

// ═══════════════════════════════════════════════════════════════════
// VALIDATION SUITE
// ═══════════════════════════════════════════════════════════════════
const TESTS = [
  { desc: 'At least 1 actionable pool recommendation found', fn: r => r.length >= 1 },
  { desc: 'Every recommendation has eliminable >= 1', fn: r => r.length > 0 && r.every(x => x.eliminable >= 1) },
  { desc: 'No duplicate vehicle appears across separate recommendations (deduplication)',
    fn: r => { const seen = new Set(); for (const rec of r) for (const id of rec.group.ids) { if (seen.has(id)) return false; seen.add(id); } return true; } },
  { desc: 'V01 & V02 are in the SAME group (merged — both daytime vans)',
    fn: r => r.some(x => x.group.ids.includes('V01') && x.group.ids.includes('V02')) },
  { desc: 'V01 & V02 group also contains V03, V04, V07 (full shift coverage merged)',
    fn: r => r.some(x => ['V01','V02','V03','V04','V07'].every(id => x.group.ids.includes(id))) },
  { desc: 'That merged 5-van group keeps 2 and removes 3 (two daytime vans = peak of 2)',
    fn: r => r.some(x => x.group.ids.includes('V01') && x.group.ids.includes('V02') && x.needed === 2 && x.eliminable === 3) },
  { desc: 'V05 & V06 appear together in a Depot South group',
    fn: r => r.some(x => x.group.ids.includes('V05') && x.group.ids.includes('V06')) },
  { desc: 'P01 & P02 appear in a pickup pool group',
    fn: r => r.some(x => x.group.ids.includes('P01') && x.group.ids.includes('P02')) },
  { desc: 'S01 (Sedan) never appears in any recommendation',
    fn: r => !r.some(x => x.group.ids.includes('S01')) },
  { desc: 'No group mixes Depot North and Depot South',
    fn: r => !r.some(x => { const locs = x.group.members.map(v => v.location); return locs.includes('Depot North') && locs.includes('Depot South'); }) },
  { desc: 'Results sorted by 3-year savings descending',
    fn: r => r.length < 2 || r[0].savings.total3yr >= r[1].savings.total3yr },
];

// ═══════════════════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════════════════
function main() {
  log('Pool Finder — starting', 'info');

  const tripMap = {}, vm = {};
  let totalTrips = 0;
  const vById = Object.fromEntries(VEHICLES.map(v => [v.id, v]));

  VEHICLES.forEach(v => {
    const trips = genTrips(v.pattern);
    tripMap[v.id] = trips;
    vm[v.id] = buildVector(trips);
    totalTrips += trips.length;
    log(`${v.id}: ${trips.length} trips built`, 'ok');
  });

  const grid = $('heatmap-grid');
  VEHICLES.forEach(v => grid.appendChild(renderVehicleCard(v, tripMap[v.id], vm[v.id])));

  log('--- Step 1: Complementary pairs ---', 'info');
  const pairs = findComplementaryPairs(VEHICLES, vm);
  const pairSet = new Set(pairs.map(p => `${p.idA}+${p.idB}`));
  log(`${pairs.length} complementary pair(s) found`, pairs.length > 0 ? 'ok' : 'err');

  const tbody = $('pairs-body');
  for (let i = 0; i < VEHICLES.length; i++) {
    for (let j = i + 1; j < VEHICLES.length; j++) {
      const vA = VEHICLES[i], vB = VEHICLES[j];
      const elig = pairEligible(vA, vB);
      const ol = elig ? cosineOverlap(vm[vA.id], vm[vB.id]) : 0;
      tbody.appendChild(renderPairRow(vA, vB, elig, ol, pairSet.has(`${vA.id}+${vB.id}`)));
    }
  }

  log('--- Step 2: Clique finding ---', 'info');
  const cliques = findCliques(VEHICLES, pairs);
  log(`${cliques.length} raw clique(s) found`, cliques.length > 0 ? 'ok' : 'warn');
  cliques.forEach(c => log(`  Clique: [${c.ids.join(', ')}]`, 'info'));

  log('--- Step 3: Merging overlapping cliques ---', 'info');
  const mergedGroups = mergeCliques(cliques, vById);
  log(`${mergedGroups.length} group(s) after merging`, 'ok');
  mergedGroups.forEach(g => log(`  Merged group: [${g.ids.join(', ')}]`, 'info'));

  log('--- Step 4: Scoring groups ---', 'info');
  const results = scoreGroups(mergedGroups, vm);

  const recList = $('rec-list');
  if (!results.length) {
    recList.innerHTML = '<div style="color:#868e96;padding:40px;text-align:center">No actionable pool groups found.</div>';
  } else {
    results.forEach((r, i) => recList.appendChild(renderRecCard(r, i)));
  }

  log('--- Validation ---', 'info');
  const valList = $('val-list');
  let passed = 0;
  TESTS.forEach(t => {
    const ok = (() => { try { return t.fn(results); } catch(e) { return false; } })();
    if (ok) passed++;
    const item = document.createElement('div'); item.className = 'val-item';
    item.innerHTML = `
      <span class="check">${ok ? '✅' : '❌'}</span>
      <div class="label">${t.desc}</div>
      <span class="badge ${ok ? 'badge-pass' : 'badge-fail'}">${ok ? 'PASS' : 'FAIL'}</span>
    `;
    valList.appendChild(item);
    log(`${ok ? 'PASS' : 'FAIL'}: ${t.desc}`, ok ? 'ok' : 'err');
  });

  const counted = new Set();
  let totalElim = 0, totalAnnual = 0, totalCapital = 0;
  results.forEach(r => {
    if (r.group.ids.every(id => !counted.has(id))) {
      r.group.ids.forEach(id => counted.add(id));
      totalElim    += r.eliminable;
      totalAnnual  += r.savings.annualOp;
      totalCapital += r.savings.capital;
    }
  });

  $('s-vehicles').textContent = VEHICLES.length;
  $('s-trips').textContent    = totalTrips.toLocaleString();
  $('s-pairs').textContent    = pairs.length;
  $('s-groups').textContent   = results.length;
  $('s-elim').textContent     = totalElim;
  $('s-annual').textContent   = fmt(totalAnnual);
  $('s-capital').textContent  = fmt(totalCapital);

  log(`Done — ${passed}/${TESTS.length} tests passed · ${totalElim} eliminable · ${fmt(totalAnnual)}/yr`, passed === TESTS.length ? 'ok' : 'warn');
}

main();
</script>
</body>
</html>
